/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package compiler.analysis.history;

import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2008-03-10T10:38:15.783+01:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "reset",
		arity = 0
	),
	@JCHR_Constraint(
		identifier = "tells",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "tell",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "reset_self",
		arity = 0
	),
	@JCHR_Constraint(
		identifier = "told",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "reactivated",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "pessimistic",
		arity = 0
	),
	@JCHR_Constraint(
		identifier = "tell_self",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "pessimistic_self",
		arity = 0
	),
	@JCHR_Constraint(
		identifier = "self",
		arity = 0
	),
	@JCHR_Constraint(
		identifier = "unknown",
		arity = 1
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
class HistoryHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	final runtime.PrimitiveAnswerSolver $solver_0;

	public HistoryHandler(runtime.PrimitiveAnswerSolver $solver_0) {
		this($solver_0, runtime.ConstraintSystem.get());
	}

	public HistoryHandler(runtime.PrimitiveAnswerSolver $solver_0, runtime.ConstraintSystem $$constraintSystem) {
		super($$constraintSystem);
		$$continuationStack = getContinuationStack();
		this.$solver_0 = $solver_0;
	}

	@Override
	public String getIdentifier() {
		return "history";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			ResetConstraint.class, 
			TellsConstraint.class, 
			TellConstraint.class, 
			Reset_selfConstraint.class, 
			ToldConstraint.class, 
			ReactivatedConstraint.class, 
			PessimisticConstraint.class, 
			Tell_selfConstraint.class, 
			Pessimistic_selfConstraint.class, 
			SelfConstraint.class, 
			UnknownConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupReset()
	 * @see #lookupTells()
	 * @see #lookupTell()
	 * @see #lookupReset_self()
	 * @see #lookupTold()
	 * @see #lookupReactivated()
	 * @see #lookupPessimistic()
	 * @see #lookupTell_self()
	 * @see #lookupPessimistic_self()
	 * @see #lookupSelf()
	 * @see #lookupUnknown()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupTells(),
			lookupTell(),
			lookupReset_self(),
			lookupPessimistic(),
			lookupTell_self(),
			lookupPessimistic_self(),
			lookupSelf(),
			lookupUnknown()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupReset()
	 * @see #lookupTells()
	 * @see #lookupTell()
	 * @see #lookupReset_self()
	 * @see #lookupTold()
	 * @see #lookupReactivated()
	 * @see #lookupPessimistic()
	 * @see #lookupTell_self()
	 * @see #lookupPessimistic_self()
	 * @see #lookupSelf()
	 * @see #lookupUnknown()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupTells(),
			lookupTell(),
			lookupReset_self(),
			lookupPessimistic(),
			lookupTell_self(),
			lookupPessimistic_self(),
			lookupSelf(),
			lookupUnknown()
		);
	}

	HistoryHandler includePackage() {
		return this;
	}
	protected HistoryHandler includeProtected() {
		return this;
	}

	@JCHR_Tells("reset")
	final void tellReset() {
		new ResetConstraint().activate();
	}

	@JCHR_Tells(
		constraint = "tells",
		warrantsStackOpimization = true
	)
	final void tellTells(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new TellsConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new TellsConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new TellsConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "tell",
		warrantsStackOpimization = true
	)
	final void tellTell(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new TellConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new TellConstraint($0));
		else
			$$continuationQueue.enqueue(new TellConstraint($0));
	}

	@JCHR_Tells("reset_self")
	final void tellReset_self() {
		new Reset_selfConstraint().activate();
	}

	@JCHR_Tells(
		constraint = "told",
		warrantsStackOpimization = true
	)
	final void tellTold(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ToldConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ToldConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new ToldConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "reactivated",
		warrantsStackOpimization = true
	)
	final void tellReactivated(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ReactivatedConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ReactivatedConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new ReactivatedConstraint($0, $1));
	}

	@JCHR_Tells("pessimistic")
	final void tellPessimistic() {
		new PessimisticConstraint().activate();
	}

	@JCHR_Tells("tell_self")
	final void tellTell_self(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		new Tell_selfConstraint($0).activate();
	}

	@JCHR_Tells("pessimistic_self")
	final void tellPessimistic_self() {
		new Pessimistic_selfConstraint().activate();
	}

	@JCHR_Tells("self")
	final void tellSelf() {
		new SelfConstraint().activate();
	}

	@JCHR_Tells(
		constraint = "unknown",
		warrantsStackOpimization = true
	)
	final void tellUnknown(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new UnknownConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new UnknownConstraint($0));
		else
			$$continuationQueue.enqueue(new UnknownConstraint($0));
	}


	/**
	 * Returns an iterator over all <code>ResetConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ResetConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ResetConstraint> lookupReset() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ResetConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupReset()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupReset
	 */
	Iterable<ResetConstraint> getResetConstraints(Filter<? super ResetConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ResetConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupReset</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ResetConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupReset
	 */
	Collection<ResetConstraint> getResetConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>ResetConstraint</code>.
	 */
	void reactivateResetConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ResetConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateResetConstraints(util.iterator.Filtered.Filter<? super ResetConstraint> filter) {
		// NOP
	}

	final HashIndex<$$tellsHashIndex_0_StorageKey> $$tellsHashIndex_0 = new HashIndex<$$tellsHashIndex_0_StorageKey>();

	private final static class $$tellsHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_0_LookupKey_0 $$tellsHashIndex_0_LookupKey_0 = new $$tellsHashIndex_0_LookupKey_0();

	private final static class $$tellsHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_0_StorageKey clone() {
			try {
				return ($$tellsHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_0_StorageKey $$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();

	final HashIndex<$$tellsHashIndex_1_StorageKey> $$tellsHashIndex_1 = new HashIndex<$$tellsHashIndex_1_StorageKey>();

	private final static class $$tellsHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_1_LookupKey_0 $$tellsHashIndex_1_LookupKey_0 = new $$tellsHashIndex_1_LookupKey_0();

	private final static class $$tellsHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_1_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_1_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_1_StorageKey clone() {
			try {
				return ($$tellsHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_1_StorageKey $$tellsHashIndex_1_StorageKey = new $$tellsHashIndex_1_StorageKey();

	protected final HashIndex<TellsConstraint> $$tellsHashIndex_2 = new HashIndex<TellsConstraint>();

	private final class $$tellsHashIndex_2_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$tellsHashIndex_2_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_2_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((TellsConstraint)other).get$0().equals(this.X0) &&
				((TellsConstraint)other).get$1().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_2_LookupKey_0 $$tellsHashIndex_2_LookupKey_0 = new $$tellsHashIndex_2_LookupKey_0();

	/**
	 * Adds the given {@link TellsConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells(TellsConstraint constraint) {
		{
			$$tellsHashIndex_0_StorageKey list;
			$$tellsHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$tellsHashIndex_0.insertOrGet($$tellsHashIndex_0_StorageKey)) == null) {
				$$tellsHashIndex_0_StorageKey.addFirst(constraint);
				$$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		{
			$$tellsHashIndex_1_StorageKey list;
			$$tellsHashIndex_1_StorageKey.init(
				constraint.get$1()
			);
			if ((list = $$tellsHashIndex_1.insertOrGet($$tellsHashIndex_1_StorageKey)) == null) {
				$$tellsHashIndex_1_StorageKey.addFirst(constraint);
				$$tellsHashIndex_1_StorageKey = new $$tellsHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$tellsHashIndex_2.putFirstTime(constraint);
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tellsHashIndex_0_LookupKey_0.init($0_value);
		return $$tellsHashIndex_0.get($$tellsHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_1_LookupKey_0.init($1_value);
		return $$tellsHashIndex_1.get($$tellsHashIndex_1_LookupKey_0);
	}

	final TellsConstraint lookupTells_2_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_2_LookupKey_0.init($0_value,$1_value);
		return $$tellsHashIndex_2.get($$tellsHashIndex_2_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>TellsConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>TellsConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<TellsConstraint> lookupTells() {
		return new NestedIterator<TellsConstraint>($$tellsHashIndex_0);
	}

	/**
	 * Returns an {@link Iterable} over all {@link TellsConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells
	 */
	Iterable<TellsConstraint> getTellsConstraints(Filter<? super TellsConstraint> filter) {
		return new FilteredIterable<TellsConstraint>(
			new NestedIterable<TellsConstraint>($$tellsHashIndex_0), filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>TellsConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>TellsConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells
	 */
	Collection<TellsConstraint> getTellsConstraints()
 {
		return new AbstractUnmodifiableCollection<TellsConstraint>() {
			@Override
			public int size() {
				return $$tellsHashIndex_2.size();
			}

			@Override
			public Iterator<TellsConstraint> iterator() {
				return lookupTells();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>.
	 */
	void reactivateTellsConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTellsConstraints(util.iterator.Filtered.Filter<? super TellsConstraint> filter) {
		// NOP
	}

	protected final HashIndex<TellConstraint> $$tellHashIndex_0 = new HashIndex<TellConstraint>();

	private final class $$tellHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tellHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((TellConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellHashIndex_0_LookupKey_0 $$tellHashIndex_0_LookupKey_0 = new $$tellHashIndex_0_LookupKey_0();

	private final runtime.DoublyLinkedConstraintList<TellConstraint> $$tellConstraintList = new runtime.DoublyLinkedConstraintList<TellConstraint>();

	/**
	 * Adds the given {@link TellConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTell(TellConstraint constraint) {
		$$tellHashIndex_0.putFirstTime(constraint);
		$$tellConstraintList.addFirst(constraint);
	}

	final TellConstraint lookupTell_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tellHashIndex_0_LookupKey_0.init($0_value);
		return $$tellHashIndex_0.get($$tellHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<TellConstraint> lookupTell_1_0() {
		return $$tellConstraintList;
	}

	/**
	 * Returns an iterator over all <code>TellConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>TellConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<TellConstraint> lookupTell() {
		return $$tellConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link TellConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTell()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTell
	 */
	Iterable<TellConstraint> getTellConstraints(Filter<? super TellConstraint> filter) {
		return new FilteredIterable<TellConstraint>($$tellConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>TellConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTell</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>TellConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTell
	 */
	Collection<TellConstraint> getTellConstraints()
 {
		return new AbstractUnmodifiableCollection<TellConstraint>() {
			@Override
			public int size() {
				return $$tellHashIndex_0.size();
			}

			@Override
			public Iterator<TellConstraint> iterator() {
				return lookupTell();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>TellConstraint</code>.
	 */
	void reactivateTellConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>TellConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTellConstraints(util.iterator.Filtered.Filter<? super TellConstraint> filter) {
		// NOP
	}

	private final runtime.DoublyLinkedConstraintList<Reset_selfConstraint> $$reset_selfConstraintList = new runtime.DoublyLinkedConstraintList<Reset_selfConstraint>();

	/**
	 * Adds the given {@link Reset_selfConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeReset_self(Reset_selfConstraint constraint) {
		$$reset_selfConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<Reset_selfConstraint> lookupReset_self_0_0() {
		return $$reset_selfConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Reset_selfConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Reset_selfConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Reset_selfConstraint> lookupReset_self() {
		return $$reset_selfConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Reset_selfConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupReset_self()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupReset_self
	 */
	Iterable<Reset_selfConstraint> getReset_selfConstraints(Filter<? super Reset_selfConstraint> filter) {
		return new FilteredIterable<Reset_selfConstraint>($$reset_selfConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Reset_selfConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupReset_self</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Reset_selfConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupReset_self
	 */
	Collection<Reset_selfConstraint> getReset_selfConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<Reset_selfConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<Reset_selfConstraint> iterator() {
				return lookupReset_self();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Reset_selfConstraint</code>.
	 */
	void reactivateReset_selfConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Reset_selfConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateReset_selfConstraints(util.iterator.Filtered.Filter<? super Reset_selfConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>ToldConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ToldConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ToldConstraint> lookupTold() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ToldConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTold()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTold
	 */
	Iterable<ToldConstraint> getToldConstraints(Filter<? super ToldConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ToldConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTold</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ToldConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTold
	 */
	Collection<ToldConstraint> getToldConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>ToldConstraint</code>.
	 */
	void reactivateToldConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ToldConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateToldConstraints(util.iterator.Filtered.Filter<? super ToldConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>ReactivatedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ReactivatedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ReactivatedConstraint> lookupReactivated() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ReactivatedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupReactivated()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupReactivated
	 */
	Iterable<ReactivatedConstraint> getReactivatedConstraints(Filter<? super ReactivatedConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ReactivatedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupReactivated</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ReactivatedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupReactivated
	 */
	Collection<ReactivatedConstraint> getReactivatedConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>ReactivatedConstraint</code>.
	 */
	void reactivateReactivatedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ReactivatedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateReactivatedConstraints(util.iterator.Filtered.Filter<? super ReactivatedConstraint> filter) {
		// NOP
	}

	private final runtime.DoublyLinkedConstraintList<PessimisticConstraint> $$pessimisticConstraintList = new runtime.DoublyLinkedConstraintList<PessimisticConstraint>();

	/**
	 * Adds the given {@link PessimisticConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storePessimistic(PessimisticConstraint constraint) {
		$$pessimisticConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<PessimisticConstraint> lookupPessimistic_0_0() {
		return $$pessimisticConstraintList;
	}

	/**
	 * Returns an iterator over all <code>PessimisticConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>PessimisticConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<PessimisticConstraint> lookupPessimistic() {
		return $$pessimisticConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link PessimisticConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupPessimistic()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupPessimistic
	 */
	Iterable<PessimisticConstraint> getPessimisticConstraints(Filter<? super PessimisticConstraint> filter) {
		return new FilteredIterable<PessimisticConstraint>($$pessimisticConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>PessimisticConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupPessimistic</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>PessimisticConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupPessimistic
	 */
	Collection<PessimisticConstraint> getPessimisticConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<PessimisticConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<PessimisticConstraint> iterator() {
				return lookupPessimistic();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>PessimisticConstraint</code>.
	 */
	void reactivatePessimisticConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>PessimisticConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivatePessimisticConstraints(util.iterator.Filtered.Filter<? super PessimisticConstraint> filter) {
		// NOP
	}

	final HashIndex<$$tell_selfHashIndex_0_StorageKey> $$tell_selfHashIndex_0 = new HashIndex<$$tell_selfHashIndex_0_StorageKey>();

	private final static class $$tell_selfHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tell_selfHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tell_selfHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tell_selfHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tell_selfHashIndex_0_LookupKey_0 $$tell_selfHashIndex_0_LookupKey_0 = new $$tell_selfHashIndex_0_LookupKey_0();

	private final static class $$tell_selfHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<Tell_selfConstraint>
		implements Cloneable<$$tell_selfHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tell_selfHashIndex_0_StorageKey() {
			// NOP
		}

		public $$tell_selfHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tell_selfHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tell_selfHashIndex_0_StorageKey clone() {
			try {
				return ($$tell_selfHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tell_selfHashIndex_0_StorageKey $$tell_selfHashIndex_0_StorageKey = new $$tell_selfHashIndex_0_StorageKey();

	private final runtime.DoublyLinkedConstraintList<Tell_selfConstraint> $$tell_selfConstraintList = new runtime.DoublyLinkedConstraintList<Tell_selfConstraint>();

	/**
	 * Adds the given {@link Tell_selfConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTell_self(Tell_selfConstraint constraint) {
		{
			$$tell_selfHashIndex_0_StorageKey list;
			$$tell_selfHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$tell_selfHashIndex_0.insertOrGet($$tell_selfHashIndex_0_StorageKey)) == null) {
				$$tell_selfHashIndex_0_StorageKey.addFirst(constraint);
				$$tell_selfHashIndex_0_StorageKey = new $$tell_selfHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$tell_selfConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<Tell_selfConstraint> lookupTell_self_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tell_selfHashIndex_0_LookupKey_0.init($0_value);
		return $$tell_selfHashIndex_0.get($$tell_selfHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<Tell_selfConstraint> lookupTell_self_1_0() {
		return $$tell_selfConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Tell_selfConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Tell_selfConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Tell_selfConstraint> lookupTell_self() {
		return $$tell_selfConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Tell_selfConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTell_self()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTell_self
	 */
	Iterable<Tell_selfConstraint> getTell_selfConstraints(Filter<? super Tell_selfConstraint> filter) {
		return new FilteredIterable<Tell_selfConstraint>($$tell_selfConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Tell_selfConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTell_self</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Tell_selfConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTell_self
	 */
	Collection<Tell_selfConstraint> getTell_selfConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<Tell_selfConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<Tell_selfConstraint> iterator() {
				return lookupTell_self();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Tell_selfConstraint</code>.
	 */
	void reactivateTell_selfConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Tell_selfConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTell_selfConstraints(util.iterator.Filtered.Filter<? super Tell_selfConstraint> filter) {
		// NOP
	}

	private final runtime.DoublyLinkedConstraintList<Pessimistic_selfConstraint> $$pessimistic_selfConstraintList = new runtime.DoublyLinkedConstraintList<Pessimistic_selfConstraint>();

	/**
	 * Adds the given {@link Pessimistic_selfConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storePessimistic_self(Pessimistic_selfConstraint constraint) {
		$$pessimistic_selfConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<Pessimistic_selfConstraint> lookupPessimistic_self_0_0() {
		return $$pessimistic_selfConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Pessimistic_selfConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Pessimistic_selfConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Pessimistic_selfConstraint> lookupPessimistic_self() {
		return $$pessimistic_selfConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Pessimistic_selfConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupPessimistic_self()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupPessimistic_self
	 */
	Iterable<Pessimistic_selfConstraint> getPessimistic_selfConstraints(Filter<? super Pessimistic_selfConstraint> filter) {
		return new FilteredIterable<Pessimistic_selfConstraint>($$pessimistic_selfConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Pessimistic_selfConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupPessimistic_self</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Pessimistic_selfConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupPessimistic_self
	 */
	Collection<Pessimistic_selfConstraint> getPessimistic_selfConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<Pessimistic_selfConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<Pessimistic_selfConstraint> iterator() {
				return lookupPessimistic_self();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Pessimistic_selfConstraint</code>.
	 */
	void reactivatePessimistic_selfConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Pessimistic_selfConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivatePessimistic_selfConstraints(util.iterator.Filtered.Filter<? super Pessimistic_selfConstraint> filter) {
		// NOP
	}

	private final runtime.DoublyLinkedConstraintList<SelfConstraint> $$selfConstraintList = new runtime.DoublyLinkedConstraintList<SelfConstraint>();

	/**
	 * Adds the given {@link SelfConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeSelf(SelfConstraint constraint) {
		$$selfConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<SelfConstraint> lookupSelf_0_0() {
		return $$selfConstraintList;
	}

	/**
	 * Returns an iterator over all <code>SelfConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>SelfConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<SelfConstraint> lookupSelf() {
		return $$selfConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link SelfConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupSelf()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupSelf
	 */
	Iterable<SelfConstraint> getSelfConstraints(Filter<? super SelfConstraint> filter) {
		return new FilteredIterable<SelfConstraint>($$selfConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>SelfConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupSelf</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>SelfConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupSelf
	 */
	Collection<SelfConstraint> getSelfConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<SelfConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<SelfConstraint> iterator() {
				return lookupSelf();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>SelfConstraint</code>.
	 */
	void reactivateSelfConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>SelfConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateSelfConstraints(util.iterator.Filtered.Filter<? super SelfConstraint> filter) {
		// NOP
	}

	protected final HashIndex<UnknownConstraint> $$unknownHashIndex_0 = new HashIndex<UnknownConstraint>();

	private final class $$unknownHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$unknownHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$unknownHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((UnknownConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$unknownHashIndex_0_LookupKey_0 $$unknownHashIndex_0_LookupKey_0 = new $$unknownHashIndex_0_LookupKey_0();

	/**
	 * Adds the given {@link UnknownConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeUnknown(UnknownConstraint constraint) {
		$$unknownHashIndex_0.putFirstTime(constraint);
	}

	final UnknownConstraint lookupUnknown_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$unknownHashIndex_0_LookupKey_0.init($0_value);
		return $$unknownHashIndex_0.get($$unknownHashIndex_0_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>UnknownConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>UnknownConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<UnknownConstraint> lookupUnknown() {
		return $$unknownHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link UnknownConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupUnknown()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupUnknown
	 */
	Iterable<UnknownConstraint> getUnknownConstraints(Filter<? super UnknownConstraint> filter) {
		return new FilteredIterable<UnknownConstraint>(
			$$unknownHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>UnknownConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupUnknown</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>UnknownConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupUnknown
	 */
	Collection<UnknownConstraint> getUnknownConstraints()
 {
		return new AbstractUnmodifiableCollection<UnknownConstraint>() {
			@Override
			public int size() {
				return $$unknownHashIndex_0.size();
			}

			@Override
			public Iterator<UnknownConstraint> iterator() {
				return lookupUnknown();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>UnknownConstraint</code>.
	 */
	void reactivateUnknownConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>UnknownConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateUnknownConstraints(util.iterator.Filtered.Filter<? super UnknownConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		{
			Iterator<? extends runtime.DoublyLinkedConstraintList<TellsConstraint>> outer = $$tellsHashIndex_0.iterator();
			while (outer.hasNext()) terminateAll(outer.next());
		}
		terminateAll($$tellConstraintList);
		terminateAll($$reset_selfConstraintList);
		terminateAll($$pessimisticConstraintList);
		terminateAll($$tell_selfConstraintList);
		terminateAll($$pessimistic_selfConstraintList);
		terminateAll($$selfConstraintList);
		terminateAll($$unknownHashIndex_0.iterator());
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.790+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "reset",
		arity = 0,
		fields = {}
	)
	final class ResetConstraint extends Continuation implements IConstraint {
		ResetConstraint() {
			// NOP
		}

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "reset";
		}

		public final int getArity() {
			return 0;
		}

		public final Object[] getArguments() {
			return new Object[] {};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean reset_1() {
			runtime.ConstraintIterable<PessimisticConstraint> pessimistic_4_lookup;
			pessimistic_4_lookup = lookupPessimistic_0_0();
			Iterator<PessimisticConstraint> pessimistic_4_iter;
			pessimistic_4_iter = pessimistic_4_lookup.semiUniversalIterator();
			PessimisticConstraint pessimistic_4;
			while (pessimistic_4_iter.hasNext()) {
				pessimistic_4 = pessimistic_4_iter.next();
				pessimistic_4.terminate();
			}
			return true;
		}

		protected final boolean reset_2() {
			runtime.ConstraintIterable<TellConstraint> tell_6_lookup;
			tell_6_lookup = lookupTell_1_0();
			Iterator<TellConstraint> tell_6_iter;
			tell_6_iter = tell_6_lookup.semiUniversalIterator();
			TellConstraint tell_6;
			while (tell_6_iter.hasNext()) {
				tell_6 = tell_6_iter.next();
				tell_6.terminate();
			}
			return true;
		}

		protected final boolean reset_3() {
			return false;
		}

		@Override
		protected Continuation call() {
			if (reset_1() && reset_2() && reset_3());
			return $$continuationStack.pop();
		}

		protected void activate() {
			if (reset_1() && reset_2() && reset_3());
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("reset(")
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.ResetConstraint);
		}

		public boolean equals(ResetConstraint other) {
			return true;
		}

		@Override
		public int hashCode() {
			int hashCode = 23;
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 108404047;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.791+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class TellsConstraint extends Constraint implements Key {
		TellsConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$1() { return this.$1; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells(TellsConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_4_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tellsHashIndex_2.remove(this);
			}
		}

		public final String getIdentifier() {
			return "tells";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$$rule_4_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation tells_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			UnknownConstraint unknown_3;
			unknown_3 = lookupUnknown_0_0(X);
			if (unknown_3 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			UnknownConstraint unknown_4;
			unknown_4 = lookupUnknown_0_0(Y);
			if (unknown_4 != null) {
				this.terminate();
				return new UnknownConstraint(X);
			}
			return null;
		}

		protected final Continuation tells_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			TellsConstraint tells_4;
			tells_4 = lookupTells_2_0(X, Y);
			if (tells_4 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_6_lookup;
			tells_6_lookup = lookupTells_1_0(Y);
			if (tells_6_lookup != null) {
				Iterator<TellsConstraint> tells_6_iter;
				tells_6_iter = tells_6_lookup.universalIterator();
				TellsConstraint tells_6;
				while (tells_6_iter.hasNext()) {
					tells_6 = tells_6_iter.next();
					if (this != tells_6) {
						if (!stored || !(tells_6.$$$rule_4_history.contains(-this.ID)
							|| !$$$rule_4_history.insert(tells_6.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_6.$0;
							stored = true;
							ID = IDcounter++;
							int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
							hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
							hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
							this.hashCode = hashCode;
							storeTells(TellsConstraint.this);

							$$$rule_4_history.add(tells_6.ID);
							if (tells_6_iter.hasNext()) {
								$$continuationStack.push(new Tells_5_1(tells_6_iter));
							} else {
								$$continuationStack.push(new Tells_6());
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation tells_6() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_5_lookup;
			tells_5_lookup = lookupTells_0_0(Y);
			if (tells_5_lookup != null) {
				Iterator<TellsConstraint> tells_5_iter;
				tells_5_iter = tells_5_lookup.universalIterator();
				TellsConstraint tells_5;
				while (tells_5_iter.hasNext()) {
					tells_5 = tells_5_iter.next();
					if (this != tells_5) {
						if (!stored || !(tells_5.$$$rule_4_history.contains(this.ID)
							|| !$$$rule_4_history.insert(-tells_5.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_5.$1;
							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeTells(TellsConstraint.this);
							}

							$$$rule_4_history.add(-tells_5.ID);
							if (tells_5_iter.hasNext()) {
								$$continuationStack.push(new Tells_6_1(tells_5_iter));
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_1()) != null) return continuation;
				if ((continuation = tells_2()) != null) return continuation;
				if ((continuation = tells_3()) != null) return continuation;
				if ((continuation = tells_5()) != null) return continuation;
				if ((continuation = tells_6()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells(TellsConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_5_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_6_iter;

			public Tells_5_1(Iterator<TellsConstraint> tells_6_iter) {
				this.tells_6_iter = tells_6_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_5_1(tells_6_iter)) != null) return continuation;
					if ((continuation = tells_6()) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_5_1")
					.append('(')
					.append("tells_6_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_5_1(Iterator<TellsConstraint> tells_6_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			TellsConstraint tells_6;
			while (tells_6_iter.hasNext()) {
				tells_6 = tells_6_iter.next();
				if (this != tells_6) {
					if (!stored || !(tells_6.$$$rule_4_history.contains(-this.ID)
						|| !$$$rule_4_history.insert(tells_6.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_6.$0;
						$$$rule_4_history.add(tells_6.ID);
						if (tells_6_iter.hasNext()) {
							$$continuationStack.undoPop();
						} else {
							$$continuationStack.push(new Tells_6());
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		protected final class Tells_6 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_6()) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_6()";
			}
		}

		protected final class Tells_6_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_5_iter;

			public Tells_6_1(Iterator<TellsConstraint> tells_5_iter) {
				this.tells_5_iter = tells_5_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_6_1(tells_5_iter)) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_6_1")
					.append('(')
					.append("tells_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_6_1(Iterator<TellsConstraint> tells_5_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			TellsConstraint tells_5;
			while (tells_5_iter.hasNext()) {
				tells_5 = tells_5_iter.next();
				if (this != tells_5) {
					if (!stored || !(tells_5.$$$rule_4_history.contains(this.ID)
						|| !$$$rule_4_history.insert(-tells_5.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_5.$1;
						$$$rule_4_history.add(-tells_5.ID);
						if (tells_5_iter.hasNext()) {
							$$continuationStack.undoPop();
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.TellsConstraint)
			    && this.equals((TellsConstraint)other);
		}

		public boolean equals(TellsConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.802+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tell",
		arity = 1,
		fields = {"$0"}
	)
	final class TellConstraint extends Constraint implements Key {
		TellConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTell(TellConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tellHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "tell";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final Continuation tell_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<SelfConstraint> self_1_lookup;
			self_1_lookup = lookupSelf_0_0();
			Iterator<SelfConstraint> self_1_iter;
			self_1_iter = self_1_lookup.semiUniversalIterator();
			SelfConstraint self_1;
			self_1_label: while (self_1_iter.hasNext()) {
				self_1 = self_1_iter.next();
				{
					runtime.ConstraintIterable<Tell_selfConstraint> not_tell_self_1_lookup;
					not_tell_self_1_lookup = lookupTell_self_0_0(X);
					if (not_tell_self_1_lookup != null) {
						Iterator<Tell_selfConstraint> not_tell_self_1_iter;
						not_tell_self_1_iter = not_tell_self_1_lookup.semiUniversalIterator();
						Tell_selfConstraint not_tell_self_1;
						if (not_tell_self_1_iter.hasNext()) {
							continue self_1_label;
						}
					}
				}
				new Tell_selfConstraint(X).activate();
			}
			return null;
		}

		protected final Continuation tell_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			UnknownConstraint unknown_5;
			unknown_5 = lookupUnknown_0_0(Y);
			if (unknown_5 != null) {
				this.terminate();
				new PessimisticConstraint().activate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tell_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			TellConstraint tell_4;
			tell_4 = lookupTell_0_0(X);
			if (tell_4 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tell_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_7_lookup;
			tells_7_lookup = lookupTells_0_0(X);
			if (tells_7_lookup != null) {
				Iterator<TellsConstraint> tells_7_iter;
				tells_7_iter = tells_7_lookup.semiUniversalIterator();
				TellsConstraint tells_7;
				while (tells_7_iter.hasNext()) {
					tells_7 = tells_7_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = tells_7.$1;
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTell(TellConstraint.this);

					if (tells_7_iter.hasNext()) {
						$$continuationStack.push(new Tell_5_1(tells_7_iter));
					}
					return new TellConstraint(Y);
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tell_1()) != null) return continuation;
				if ((continuation = tell_2()) != null) return continuation;
				if ((continuation = tell_3()) != null) return continuation;
				if ((continuation = tell_5()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTell(TellConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Tell_5_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_7_iter;

			public Tell_5_1(Iterator<TellsConstraint> tells_7_iter) {
				this.tells_7_iter = tells_7_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tell_5_1(tells_7_iter)) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tell_5_1")
					.append('(')
					.append("tells_7_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tell_5_1(Iterator<TellsConstraint> tells_7_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			TellsConstraint tells_7;
			do {
				tells_7 = tells_7_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = tells_7.$1;
				if (tells_7_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new TellConstraint(Y);
			} while (tells_7_iter.hasNext());
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tell(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.TellConstraint)
			    && this.equals((TellConstraint)other);
		}

		public boolean equals(TellConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.807+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "reset_self",
		arity = 0,
		fields = {}
	)
	final class Reset_selfConstraint extends Constraint {
		Reset_selfConstraint() {
			// NOP
		}

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeReset_self(Reset_selfConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "reset_self";
		}

		public final int getArity() {
			return 0;
		}

		public final Object[] getArguments() {
			return new Object[] {};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean reset_self_1() {
			runtime.ConstraintIterable<Pessimistic_selfConstraint> pessimistic_self_1_lookup;
			pessimistic_self_1_lookup = lookupPessimistic_self_0_0();
			Iterator<Pessimistic_selfConstraint> pessimistic_self_1_iter;
			pessimistic_self_1_iter = pessimistic_self_1_lookup.semiUniversalIterator();
			Pessimistic_selfConstraint pessimistic_self_1;
			while (pessimistic_self_1_iter.hasNext()) {
				pessimistic_self_1 = pessimistic_self_1_iter.next();
				pessimistic_self_1.terminate();
			}
			return true;
		}

		protected final boolean reset_self_2() {
			runtime.ConstraintIterable<Tell_selfConstraint> tell_self_1_lookup;
			tell_self_1_lookup = lookupTell_self_1_0();
			Iterator<Tell_selfConstraint> tell_self_1_iter;
			tell_self_1_iter = tell_self_1_lookup.semiUniversalIterator();
			Tell_selfConstraint tell_self_1;
			while (tell_self_1_iter.hasNext()) {
				tell_self_1 = tell_self_1_iter.next();
				tell_self_1.terminate();
			}
			return true;
		}

		protected final boolean reset_self_3() {
			runtime.ConstraintIterable<SelfConstraint> self_3_lookup;
			self_3_lookup = lookupSelf_0_0();
			Iterator<SelfConstraint> self_3_iter;
			self_3_iter = self_3_lookup.existentialIterator();
			SelfConstraint self_3;
			while (self_3_iter.hasNext()) {
				self_3 = self_3_iter.next();
				this.terminate();
				self_3.terminate();
				return false;
			}
			return true;
		}

		@Override
		protected Continuation call() {
			if (reset_self_1() && reset_self_2() && reset_self_3()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeReset_self(Reset_selfConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}

		@Override
		protected void activate() {
			if (reset_self_1() && reset_self_2() && reset_self_3()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeReset_self(Reset_selfConstraint.this);
				}
			}
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("reset_self(")
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.Reset_selfConstraint);
		}

		public boolean equals(Reset_selfConstraint other) {
			return true;
		}

		@Override
		public int hashCode() {
			int hashCode = 23;
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -1676450756;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.810+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "told",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class ToldConstraint extends Continuation implements IConstraint {
		ToldConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final runtime.BooleanAnswer $1;
		public runtime.BooleanAnswer get$1() { return this.$1; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "told";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				runtime.BooleanAnswer.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final Continuation told_1() {
			runtime.BooleanAnswer R = this.$1;
			runtime.ConstraintIterable<Pessimistic_selfConstraint> pessimistic_self_3_lookup;
			pessimistic_self_3_lookup = lookupPessimistic_self_0_0();
			Iterator<Pessimistic_selfConstraint> pessimistic_self_3_iter;
			pessimistic_self_3_iter = pessimistic_self_3_lookup.existentialIterator();
			Pessimistic_selfConstraint pessimistic_self_3;
			while (pessimistic_self_3_iter.hasNext()) {
				pessimistic_self_3 = pessimistic_self_3_iter.next();
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation told_2() {
			runtime.BooleanAnswer R = this.$1;
			runtime.ConstraintIterable<PessimisticConstraint> pessimistic_6_lookup;
			pessimistic_6_lookup = lookupPessimistic_0_0();
			Iterator<PessimisticConstraint> pessimistic_6_iter;
			pessimistic_6_iter = pessimistic_6_lookup.existentialIterator();
			PessimisticConstraint pessimistic_6;
			pessimistic_6_label: while (pessimistic_6_iter.hasNext()) {
				pessimistic_6 = pessimistic_6_iter.next();
				{
					runtime.ConstraintIterable<SelfConstraint> not_self_2_lookup;
					not_self_2_lookup = lookupSelf_0_0();
					Iterator<SelfConstraint> not_self_2_iter;
					not_self_2_iter = not_self_2_lookup.existentialIterator();
					SelfConstraint not_self_2;
					if (not_self_2_iter.hasNext()) {
						continue pessimistic_6_label;
					}
				}
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation told_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.BooleanAnswer R = this.$1;
			runtime.ConstraintIterable<Tell_selfConstraint> tell_self_2_lookup;
			tell_self_2_lookup = lookupTell_self_0_0(X);
			if (tell_self_2_lookup != null) {
				Iterator<Tell_selfConstraint> tell_self_2_iter;
				tell_self_2_iter = tell_self_2_lookup.existentialIterator();
				Tell_selfConstraint tell_self_2;
				while (tell_self_2_iter.hasNext()) {
					tell_self_2 = tell_self_2_iter.next();
					$solver_0.tellEqual(R, true);
					return $$continuationStack.pop();
				}
			}
			return null;
		}

		protected final Continuation told_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.BooleanAnswer R = this.$1;
			TellConstraint tell_7;
			tell_7 = lookupTell_0_0(X);
			if (tell_7 != null) {
				{
					runtime.ConstraintIterable<SelfConstraint> not_self_3_lookup;
					not_self_3_lookup = lookupSelf_0_0();
					Iterator<SelfConstraint> not_self_3_iter;
					not_self_3_iter = not_self_3_lookup.existentialIterator();
					SelfConstraint not_self_3;
					if (not_self_3_iter.hasNext()) {
						return null;
					}
				}
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation told_5() {
			runtime.BooleanAnswer R = this.$1;
			$solver_0.tellEqual(R, false);
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = told_1()) != null) return continuation;
				if ((continuation = told_2()) != null) return continuation;
				if ((continuation = told_3()) != null) return continuation;
				if ((continuation = told_4()) != null) return continuation;
				if ((continuation = told_5()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("told(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.ToldConstraint)
			    && this.equals((ToldConstraint)other);
		}

		public boolean equals(ToldConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 3565875;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.816+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "reactivated",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class ReactivatedConstraint extends Continuation implements IConstraint {
		ReactivatedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final runtime.BooleanAnswer $1;
		public runtime.BooleanAnswer get$1() { return this.$1; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "reactivated";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				runtime.BooleanAnswer.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final Continuation reactivated_1() {
			runtime.BooleanAnswer R = this.$1;
			runtime.ConstraintIterable<Pessimistic_selfConstraint> pessimistic_self_2_lookup;
			pessimistic_self_2_lookup = lookupPessimistic_self_0_0();
			Iterator<Pessimistic_selfConstraint> pessimistic_self_2_iter;
			pessimistic_self_2_iter = pessimistic_self_2_lookup.existentialIterator();
			Pessimistic_selfConstraint pessimistic_self_2;
			while (pessimistic_self_2_iter.hasNext()) {
				pessimistic_self_2 = pessimistic_self_2_iter.next();
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation reactivated_2() {
			runtime.BooleanAnswer R = this.$1;
			runtime.ConstraintIterable<PessimisticConstraint> pessimistic_5_lookup;
			pessimistic_5_lookup = lookupPessimistic_0_0();
			Iterator<PessimisticConstraint> pessimistic_5_iter;
			pessimistic_5_iter = pessimistic_5_lookup.existentialIterator();
			PessimisticConstraint pessimistic_5;
			pessimistic_5_label: while (pessimistic_5_iter.hasNext()) {
				pessimistic_5 = pessimistic_5_iter.next();
				{
					runtime.ConstraintIterable<SelfConstraint> not_self_1_lookup;
					not_self_1_lookup = lookupSelf_0_0();
					Iterator<SelfConstraint> not_self_1_iter;
					not_self_1_iter = not_self_1_lookup.existentialIterator();
					SelfConstraint not_self_1;
					if (not_self_1_iter.hasNext()) {
						continue pessimistic_5_label;
					}
				}
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation reactivated_3() {
			runtime.BooleanAnswer R = this.$1;
			$solver_0.tellEqual(R, false);
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = reactivated_1()) != null) return continuation;
				if ((continuation = reactivated_2()) != null) return continuation;
				if ((continuation = reactivated_3()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("reactivated(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.ReactivatedConstraint)
			    && this.equals((ReactivatedConstraint)other);
		}

		public boolean equals(ReactivatedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -1157626626;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.817+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "pessimistic",
		arity = 0,
		fields = {}
	)
	final class PessimisticConstraint extends Constraint {
		PessimisticConstraint() {
			// NOP
		}

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storePessimistic(PessimisticConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "pessimistic";
		}

		public final int getArity() {
			return 0;
		}

		public final Object[] getArguments() {
			return new Object[] {};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean pessimistic_1() {
			runtime.ConstraintIterable<SelfConstraint> self_2_lookup;
			self_2_lookup = lookupSelf_0_0();
			Iterator<SelfConstraint> self_2_iter;
			self_2_iter = self_2_lookup.semiUniversalIterator();
			SelfConstraint self_2;
			self_2_label: while (self_2_iter.hasNext()) {
				self_2 = self_2_iter.next();
				{
					runtime.ConstraintIterable<Pessimistic_selfConstraint> not_pessimistic_self_1_lookup;
					not_pessimistic_self_1_lookup = lookupPessimistic_self_0_0();
					Iterator<Pessimistic_selfConstraint> not_pessimistic_self_1_iter;
					not_pessimistic_self_1_iter = not_pessimistic_self_1_lookup.semiUniversalIterator();
					Pessimistic_selfConstraint not_pessimistic_self_1;
					if (not_pessimistic_self_1_iter.hasNext()) {
						continue self_2_label;
					}
				}
				new Pessimistic_selfConstraint().activate();
			}
			return true;
		}

		protected final boolean pessimistic_2() {
			runtime.ConstraintIterable<PessimisticConstraint> pessimistic_3_lookup;
			pessimistic_3_lookup = lookupPessimistic_0_0();
			Iterator<PessimisticConstraint> pessimistic_3_iter;
			pessimistic_3_iter = pessimistic_3_lookup.existentialIterator();
			PessimisticConstraint pessimistic_3;
			while (pessimistic_3_iter.hasNext()) {
				pessimistic_3 = pessimistic_3_iter.next();
				this.terminate();
				return false;
			}
			return true;
		}

		@Override
		protected Continuation call() {
			if (pessimistic_1() && pessimistic_2()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storePessimistic(PessimisticConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}

		@Override
		protected void activate() {
			if (pessimistic_1() && pessimistic_2()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storePessimistic(PessimisticConstraint.this);
				}
			}
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("pessimistic(")
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.PessimisticConstraint);
		}

		public boolean equals(PessimisticConstraint other) {
			return true;
		}

		@Override
		public int hashCode() {
			int hashCode = 23;
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 1012469707;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.819+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tell_self",
		arity = 1,
		fields = {"$0"}
	)
	final class Tell_selfConstraint extends Constraint {
		Tell_selfConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeTell_self(Tell_selfConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "tell_self";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean tell_self_1() {
			runtime.ConstraintIterable<Reset_selfConstraint> reset_self_2_lookup;
			reset_self_2_lookup = lookupReset_self_0_0();
			Iterator<Reset_selfConstraint> reset_self_2_iter;
			reset_self_2_iter = reset_self_2_lookup.existentialIterator();
			Reset_selfConstraint reset_self_2;
			while (reset_self_2_iter.hasNext()) {
				reset_self_2 = reset_self_2_iter.next();
				this.terminate();
				return false;
			}
			return true;
		}

		@Override
		protected Continuation call() {
			if (tell_self_1()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeTell_self(Tell_selfConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}

		@Override
		protected void activate() {
			if (tell_self_1()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeTell_self(Tell_selfConstraint.this);
				}
			}
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("tell_self(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.Tell_selfConstraint)
			    && this.equals((Tell_selfConstraint)other);
		}

		public boolean equals(Tell_selfConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 968223514;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.820+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "pessimistic_self",
		arity = 0,
		fields = {}
	)
	final class Pessimistic_selfConstraint extends Constraint {
		Pessimistic_selfConstraint() {
			// NOP
		}

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storePessimistic_self(Pessimistic_selfConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "pessimistic_self";
		}

		public final int getArity() {
			return 0;
		}

		public final Object[] getArguments() {
			return new Object[] {};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean pessimistic_self_1() {
			runtime.ConstraintIterable<Reset_selfConstraint> reset_self_1_lookup;
			reset_self_1_lookup = lookupReset_self_0_0();
			Iterator<Reset_selfConstraint> reset_self_1_iter;
			reset_self_1_iter = reset_self_1_lookup.existentialIterator();
			Reset_selfConstraint reset_self_1;
			while (reset_self_1_iter.hasNext()) {
				reset_self_1 = reset_self_1_iter.next();
				this.terminate();
				return false;
			}
			return true;
		}

		@Override
		protected Continuation call() {
			if (pessimistic_self_1()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storePessimistic_self(Pessimistic_selfConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}

		@Override
		protected void activate() {
			if (pessimistic_self_1()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storePessimistic_self(Pessimistic_selfConstraint.this);
				}
			}
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("pessimistic_self(")
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.Pessimistic_selfConstraint);
		}

		public boolean equals(Pessimistic_selfConstraint other) {
			return true;
		}

		@Override
		public int hashCode() {
			int hashCode = 23;
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -1949262016;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.821+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "self",
		arity = 0,
		fields = {}
	)
	final class SelfConstraint extends Constraint {
		SelfConstraint() {
			// NOP
		}

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeSelf(SelfConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "self";
		}

		public final int getArity() {
			return 0;
		}

		public final Object[] getArguments() {
			return new Object[] {};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final boolean self_3() {
			runtime.ConstraintIterable<Reset_selfConstraint> reset_self_3_lookup;
			reset_self_3_lookup = lookupReset_self_0_0();
			Iterator<Reset_selfConstraint> reset_self_3_iter;
			reset_self_3_iter = reset_self_3_lookup.existentialIterator();
			Reset_selfConstraint reset_self_3;
			while (reset_self_3_iter.hasNext()) {
				reset_self_3 = reset_self_3_iter.next();
				reset_self_3.terminate();
				this.terminate();
				return false;
			}
			return true;
		}

		@Override
		protected Continuation call() {
			if (self_3()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeSelf(SelfConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}

		@Override
		protected void activate() {
			if (self_3()) {
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeSelf(SelfConstraint.this);
				}
			}
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("self(")
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.SelfConstraint);
		}

		public boolean equals(SelfConstraint other) {
			return true;
		}

		@Override
		public int hashCode() {
			int hashCode = 23;
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 3526476;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.822+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "unknown",
		arity = 1,
		fields = {"$0"}
	)
	final class UnknownConstraint extends Constraint implements Key {
		UnknownConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeUnknown(UnknownConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$unknownHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "unknown";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final HistoryHandler getHandler() {
			return HistoryHandler.this;
		}

		protected final Continuation unknown_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			UnknownConstraint unknown_2;
			unknown_2 = lookupUnknown_0_0(X);
			if (unknown_2 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation unknown_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_1_lookup;
			tells_1_lookup = lookupTells_0_0(X);
			if (tells_1_lookup != null) {
				Iterator<TellsConstraint> tells_1_iter;
				tells_1_iter = tells_1_lookup.semiUniversalIterator();
				TellsConstraint tells_1;
				while (tells_1_iter.hasNext()) {
					tells_1 = tells_1_iter.next();
					tells_1.terminate();
				}
			}
			return null;
		}

		protected final Continuation unknown_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_2_lookup;
			tells_2_lookup = lookupTells_1_0(Y);
			if (tells_2_lookup != null) {
				Iterator<TellsConstraint> tells_2_iter;
				tells_2_iter = tells_2_lookup.universalIterator();
				TellsConstraint tells_2;
				while (tells_2_iter.hasNext()) {
					tells_2 = tells_2_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_2.$0;
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeUnknown(UnknownConstraint.this);

					tells_2.terminate();
					if (tells_2_iter.hasNext()) {
						$$continuationStack.push(new Unknown_4_1(tells_2_iter));
					}
					return new UnknownConstraint(X);
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = unknown_1()) != null) return continuation;
				if ((continuation = unknown_3()) != null) return continuation;
				if ((continuation = unknown_4()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeUnknown(UnknownConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Unknown_4_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_2_iter;

			public Unknown_4_1(Iterator<TellsConstraint> tells_2_iter) {
				this.tells_2_iter = tells_2_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = unknown_4_1(tells_2_iter)) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Unknown_4_1")
					.append('(')
					.append("tells_2_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation unknown_4_1(Iterator<TellsConstraint> tells_2_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			TellsConstraint tells_2;
			while (tells_2_iter.hasNext()) {
				tells_2 = tells_2_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_2.$0;
				tells_2.terminate();
				if (tells_2_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new UnknownConstraint(X);
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("unknown(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof HistoryHandler.UnknownConstraint)
			    && this.equals((UnknownConstraint)other);
		}

		public boolean equals(UnknownConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == ResetConstraint.class)
			return false;
		if (constraintClass == TellsConstraint.class)
			return true;
		if (constraintClass == TellConstraint.class)
			return true;
		if (constraintClass == Reset_selfConstraint.class)
			return true;
		if (constraintClass == ToldConstraint.class)
			return false;
		if (constraintClass == ReactivatedConstraint.class)
			return false;
		if (constraintClass == PessimisticConstraint.class)
			return true;
		if (constraintClass == Tell_selfConstraint.class)
			return true;
		if (constraintClass == Pessimistic_selfConstraint.class)
			return true;
		if (constraintClass == SelfConstraint.class)
			return true;
		if (constraintClass == UnknownConstraint.class)
			return true;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
