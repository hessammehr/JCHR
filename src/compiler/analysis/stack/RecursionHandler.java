/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package compiler.analysis.stack;

import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2008-03-10T10:38:16.128+01:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "reactivates",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "cons",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "reactive",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "tells",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "exported",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "is_recursive",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "recursive",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "tells_exported",
		arity = 1
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
class RecursionHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	final runtime.PrimitiveAnswerSolver $solver_0;

	public RecursionHandler(runtime.PrimitiveAnswerSolver $solver_0) {
		this($solver_0, runtime.ConstraintSystem.get());
	}

	public RecursionHandler(runtime.PrimitiveAnswerSolver $solver_0, runtime.ConstraintSystem $$constraintSystem) {
		super($$constraintSystem);
		$$continuationStack = getContinuationStack();
		this.$solver_0 = $solver_0;
	}

	@Override
	public String getIdentifier() {
		return "recursion";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			ReactivatesConstraint.class, 
			ConsConstraint.class, 
			ReactiveConstraint.class, 
			TellsConstraint.class, 
			ExportedConstraint.class, 
			Is_recursiveConstraint.class, 
			RecursiveConstraint.class, 
			Tells_exportedConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupReactivates()
	 * @see #lookupCons()
	 * @see #lookupReactive()
	 * @see #lookupTells()
	 * @see #lookupExported()
	 * @see #lookupIs_recursive()
	 * @see #lookupRecursive()
	 * @see #lookupTells_exported()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupReactivates(),
			lookupReactive(),
			lookupTells(),
			lookupExported(),
			lookupRecursive(),
			lookupTells_exported()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupReactivates()
	 * @see #lookupCons()
	 * @see #lookupReactive()
	 * @see #lookupTells()
	 * @see #lookupExported()
	 * @see #lookupIs_recursive()
	 * @see #lookupRecursive()
	 * @see #lookupTells_exported()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupReactivates(),
			lookupReactive(),
			lookupTells(),
			lookupExported(),
			lookupRecursive(),
			lookupTells_exported()
		);
	}

	RecursionHandler includePackage() {
		return this;
	}
	protected RecursionHandler includeProtected() {
		return this;
	}

	@JCHR_Tells(
		constraint = "reactivates",
		warrantsStackOpimization = true
	)
	final void tellReactivates(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ReactivatesConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ReactivatesConstraint($0));
		else
			$$continuationQueue.enqueue(new ReactivatesConstraint($0));
	}

	@JCHR_Tells(
		constraint = "cons",
		warrantsStackOpimization = true
	)
	final void tellCons(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ConsConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ConsConstraint($0));
		else
			$$continuationQueue.enqueue(new ConsConstraint($0));
	}

	@JCHR_Tells(
		constraint = "reactive",
		warrantsStackOpimization = true
	)
	private final void tellReactive(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ReactiveConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ReactiveConstraint($0));
		else
			$$continuationQueue.enqueue(new ReactiveConstraint($0));
	}

	@JCHR_Tells(
		constraint = "tells",
		warrantsStackOpimization = true
	)
	final void tellTells(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new TellsConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new TellsConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new TellsConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "exported",
		warrantsStackOpimization = true
	)
	final void tellExported(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ExportedConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ExportedConstraint($0));
		else
			$$continuationQueue.enqueue(new ExportedConstraint($0));
	}

	@JCHR_Tells(
		constraint = "is_recursive",
		warrantsStackOpimization = true
	)
	final void tellIs_recursive(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new Is_recursiveConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new Is_recursiveConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new Is_recursiveConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "recursive",
		warrantsStackOpimization = true
	)
	final void tellRecursive(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new RecursiveConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new RecursiveConstraint($0));
		else
			$$continuationQueue.enqueue(new RecursiveConstraint($0));
	}

	@JCHR_Tells(
		constraint = "tells_exported",
		warrantsStackOpimization = true
	)
	final void tellTells_exported(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new Tells_exportedConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new Tells_exportedConstraint($0));
		else
			$$continuationQueue.enqueue(new Tells_exportedConstraint($0));
	}

	final HashIndex<$$reactivatesHashIndex_0_StorageKey> $$reactivatesHashIndex_0 = new HashIndex<$$reactivatesHashIndex_0_StorageKey>();

	private final static class $$reactivatesHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$reactivatesHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$reactivatesHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$reactivatesHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$reactivatesHashIndex_0_LookupKey_0 $$reactivatesHashIndex_0_LookupKey_0 = new $$reactivatesHashIndex_0_LookupKey_0();

	private final static class $$reactivatesHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<ReactivatesConstraint>
		implements Cloneable<$$reactivatesHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$reactivatesHashIndex_0_StorageKey() {
			// NOP
		}

		public $$reactivatesHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$reactivatesHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$reactivatesHashIndex_0_StorageKey clone() {
			try {
				return ($$reactivatesHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$reactivatesHashIndex_0_StorageKey $$reactivatesHashIndex_0_StorageKey = new $$reactivatesHashIndex_0_StorageKey();

	private final runtime.DoublyLinkedConstraintList<ReactivatesConstraint> $$reactivatesConstraintList = new runtime.DoublyLinkedConstraintList<ReactivatesConstraint>();

	/**
	 * Adds the given {@link ReactivatesConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeReactivates(ReactivatesConstraint constraint) {
		{
			$$reactivatesHashIndex_0_StorageKey list;
			$$reactivatesHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$reactivatesHashIndex_0.insertOrGet($$reactivatesHashIndex_0_StorageKey)) == null) {
				$$reactivatesHashIndex_0_StorageKey.addFirst(constraint);
				$$reactivatesHashIndex_0_StorageKey = new $$reactivatesHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$reactivatesConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<ReactivatesConstraint> lookupReactivates_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$reactivatesHashIndex_0_LookupKey_0.init($0_value);
		return $$reactivatesHashIndex_0.get($$reactivatesHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<ReactivatesConstraint> lookupReactivates_1_0() {
		return $$reactivatesConstraintList;
	}

	/**
	 * Returns an iterator over all <code>ReactivatesConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ReactivatesConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ReactivatesConstraint> lookupReactivates() {
		return $$reactivatesConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ReactivatesConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupReactivates()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupReactivates
	 */
	Iterable<ReactivatesConstraint> getReactivatesConstraints(Filter<? super ReactivatesConstraint> filter) {
		return new FilteredIterable<ReactivatesConstraint>($$reactivatesConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ReactivatesConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupReactivates</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ReactivatesConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupReactivates
	 */
	Collection<ReactivatesConstraint> getReactivatesConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<ReactivatesConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<ReactivatesConstraint> iterator() {
				return lookupReactivates();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ReactivatesConstraint</code>.
	 */
	void reactivateReactivatesConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ReactivatesConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateReactivatesConstraints(util.iterator.Filtered.Filter<? super ReactivatesConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>ConsConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ConsConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ConsConstraint> lookupCons() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ConsConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupCons()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupCons
	 */
	Iterable<ConsConstraint> getConsConstraints(Filter<? super ConsConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ConsConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupCons</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ConsConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupCons
	 */
	Collection<ConsConstraint> getConsConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>ConsConstraint</code>.
	 */
	void reactivateConsConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ConsConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateConsConstraints(util.iterator.Filtered.Filter<? super ConsConstraint> filter) {
		// NOP
	}

	private final runtime.SinglyLinkedConstraintList<ReactiveConstraint> $$reactiveConstraintList = new runtime.SinglyLinkedConstraintList<ReactiveConstraint>();

	/**
	 * Adds the given {@link ReactiveConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeReactive(ReactiveConstraint constraint) {
		$$reactiveConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<ReactiveConstraint> lookupReactive_0_0() {
		return $$reactiveConstraintList;
	}

	/**
	 * Returns an iterator over all <code>ReactiveConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ReactiveConstraint</code>s currently
	 * 	in the constraint store.
	 */
	public  Iterator<ReactiveConstraint> lookupReactive() {
		return $$reactiveConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ReactiveConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupReactive()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupReactive
	 */
	public  Iterable<ReactiveConstraint> getReactiveConstraints(Filter<? super ReactiveConstraint> filter) {
		return new FilteredIterable<ReactiveConstraint>($$reactiveConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ReactiveConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupReactive</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ReactiveConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupReactive
	 */
	public  Collection<ReactiveConstraint> getReactiveConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<ReactiveConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<ReactiveConstraint> iterator() {
				return lookupReactive();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ReactiveConstraint</code>.
	 */
	public  void reactivateReactiveConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ReactiveConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	public  void reactivateReactiveConstraints(util.iterator.Filtered.Filter<? super ReactiveConstraint> filter) {
		// NOP
	}

	final HashIndex<$$tellsHashIndex_0_StorageKey> $$tellsHashIndex_0 = new HashIndex<$$tellsHashIndex_0_StorageKey>();

	private final static class $$tellsHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_0_LookupKey_0 $$tellsHashIndex_0_LookupKey_0 = new $$tellsHashIndex_0_LookupKey_0();

	private final static class $$tellsHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_0_StorageKey clone() {
			try {
				return ($$tellsHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_0_StorageKey $$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();

	protected final HashIndex<TellsConstraint> $$tellsHashIndex_1 = new HashIndex<TellsConstraint>();

	private final class $$tellsHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$tellsHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((TellsConstraint)other).get$0().equals(this.X0) &&
				((TellsConstraint)other).get$1().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_1_LookupKey_0 $$tellsHashIndex_1_LookupKey_0 = new $$tellsHashIndex_1_LookupKey_0();

	final HashIndex<$$tellsHashIndex_2_StorageKey> $$tellsHashIndex_2 = new HashIndex<$$tellsHashIndex_2_StorageKey>();

	private final static class $$tellsHashIndex_2_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_2_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_2_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_2_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_2_LookupKey_0 $$tellsHashIndex_2_LookupKey_0 = new $$tellsHashIndex_2_LookupKey_0();

	private final static class $$tellsHashIndex_2_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_2_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_2_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_2_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_2_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_2_StorageKey clone() {
			try {
				return ($$tellsHashIndex_2_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_2_StorageKey $$tellsHashIndex_2_StorageKey = new $$tellsHashIndex_2_StorageKey();

	/**
	 * Adds the given {@link TellsConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells(TellsConstraint constraint) {
		{
			$$tellsHashIndex_0_StorageKey list;
			$$tellsHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$tellsHashIndex_0.insertOrGet($$tellsHashIndex_0_StorageKey)) == null) {
				$$tellsHashIndex_0_StorageKey.addFirst(constraint);
				$$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$tellsHashIndex_1.putFirstTime(constraint);
		{
			$$tellsHashIndex_2_StorageKey list;
			$$tellsHashIndex_2_StorageKey.init(
				constraint.get$1()
			);
			if ((list = $$tellsHashIndex_2.insertOrGet($$tellsHashIndex_2_StorageKey)) == null) {
				$$tellsHashIndex_2_StorageKey.addFirst(constraint);
				$$tellsHashIndex_2_StorageKey = new $$tellsHashIndex_2_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tellsHashIndex_0_LookupKey_0.init($0_value);
		return $$tellsHashIndex_0.get($$tellsHashIndex_0_LookupKey_0);
	}

	final TellsConstraint lookupTells_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_1_LookupKey_0.init($0_value,$1_value);
		return $$tellsHashIndex_1.get($$tellsHashIndex_1_LookupKey_0);
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_2_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_2_LookupKey_0.init($1_value);
		return $$tellsHashIndex_2.get($$tellsHashIndex_2_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>TellsConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>TellsConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<TellsConstraint> lookupTells() {
		return new NestedIterator<TellsConstraint>($$tellsHashIndex_0);
	}

	/**
	 * Returns an {@link Iterable} over all {@link TellsConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells
	 */
	Iterable<TellsConstraint> getTellsConstraints(Filter<? super TellsConstraint> filter) {
		return new FilteredIterable<TellsConstraint>(
			new NestedIterable<TellsConstraint>($$tellsHashIndex_0), filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>TellsConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>TellsConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells
	 */
	Collection<TellsConstraint> getTellsConstraints()
 {
		return new AbstractUnmodifiableCollection<TellsConstraint>() {
			@Override
			public int size() {
				return $$tellsHashIndex_1.size();
			}

			@Override
			public Iterator<TellsConstraint> iterator() {
				return lookupTells();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>.
	 */
	void reactivateTellsConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTellsConstraints(util.iterator.Filtered.Filter<? super TellsConstraint> filter) {
		// NOP
	}

	private final runtime.SinglyLinkedConstraintList<ExportedConstraint> $$exportedConstraintList = new runtime.SinglyLinkedConstraintList<ExportedConstraint>();

	/**
	 * Adds the given {@link ExportedConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeExported(ExportedConstraint constraint) {
		$$exportedConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<ExportedConstraint> lookupExported_0_0() {
		return $$exportedConstraintList;
	}

	/**
	 * Returns an iterator over all <code>ExportedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ExportedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ExportedConstraint> lookupExported() {
		return $$exportedConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ExportedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupExported()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupExported
	 */
	Iterable<ExportedConstraint> getExportedConstraints(Filter<? super ExportedConstraint> filter) {
		return new FilteredIterable<ExportedConstraint>($$exportedConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ExportedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupExported</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ExportedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupExported
	 */
	Collection<ExportedConstraint> getExportedConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<ExportedConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<ExportedConstraint> iterator() {
				return lookupExported();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ExportedConstraint</code>.
	 */
	void reactivateExportedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ExportedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateExportedConstraints(util.iterator.Filtered.Filter<? super ExportedConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>Is_recursiveConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Is_recursiveConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Is_recursiveConstraint> lookupIs_recursive() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Is_recursiveConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupIs_recursive()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupIs_recursive
	 */
	Iterable<Is_recursiveConstraint> getIs_recursiveConstraints(Filter<? super Is_recursiveConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Is_recursiveConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupIs_recursive</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Is_recursiveConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupIs_recursive
	 */
	Collection<Is_recursiveConstraint> getIs_recursiveConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>Is_recursiveConstraint</code>.
	 */
	void reactivateIs_recursiveConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Is_recursiveConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateIs_recursiveConstraints(util.iterator.Filtered.Filter<? super Is_recursiveConstraint> filter) {
		// NOP
	}

	protected final HashIndex<RecursiveConstraint> $$recursiveHashIndex_0 = new HashIndex<RecursiveConstraint>();

	private final class $$recursiveHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$recursiveHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$recursiveHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((RecursiveConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$recursiveHashIndex_0_LookupKey_0 $$recursiveHashIndex_0_LookupKey_0 = new $$recursiveHashIndex_0_LookupKey_0();

	/**
	 * Adds the given {@link RecursiveConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeRecursive(RecursiveConstraint constraint) {
		$$recursiveHashIndex_0.putFirstTime(constraint);
	}

	final RecursiveConstraint lookupRecursive_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$recursiveHashIndex_0_LookupKey_0.init($0_value);
		return $$recursiveHashIndex_0.get($$recursiveHashIndex_0_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>RecursiveConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>RecursiveConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<RecursiveConstraint> lookupRecursive() {
		return $$recursiveHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link RecursiveConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupRecursive()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupRecursive
	 */
	Iterable<RecursiveConstraint> getRecursiveConstraints(Filter<? super RecursiveConstraint> filter) {
		return new FilteredIterable<RecursiveConstraint>(
			$$recursiveHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>RecursiveConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupRecursive</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>RecursiveConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupRecursive
	 */
	Collection<RecursiveConstraint> getRecursiveConstraints()
 {
		return new AbstractUnmodifiableCollection<RecursiveConstraint>() {
			@Override
			public int size() {
				return $$recursiveHashIndex_0.size();
			}

			@Override
			public Iterator<RecursiveConstraint> iterator() {
				return lookupRecursive();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>RecursiveConstraint</code>.
	 */
	void reactivateRecursiveConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>RecursiveConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateRecursiveConstraints(util.iterator.Filtered.Filter<? super RecursiveConstraint> filter) {
		// NOP
	}

	final HashIndex<$$tells_exportedHashIndex_0_StorageKey> $$tells_exportedHashIndex_0 = new HashIndex<$$tells_exportedHashIndex_0_StorageKey>();

	private final static class $$tells_exportedHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tells_exportedHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tells_exportedHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tells_exportedHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tells_exportedHashIndex_0_LookupKey_0 $$tells_exportedHashIndex_0_LookupKey_0 = new $$tells_exportedHashIndex_0_LookupKey_0();

	private final static class $$tells_exportedHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<Tells_exportedConstraint>
		implements Cloneable<$$tells_exportedHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tells_exportedHashIndex_0_StorageKey() {
			// NOP
		}

		public $$tells_exportedHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tells_exportedHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tells_exportedHashIndex_0_StorageKey clone() {
			try {
				return ($$tells_exportedHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tells_exportedHashIndex_0_StorageKey $$tells_exportedHashIndex_0_StorageKey = new $$tells_exportedHashIndex_0_StorageKey();

	private final runtime.DoublyLinkedConstraintList<Tells_exportedConstraint> $$tells_exportedConstraintList = new runtime.DoublyLinkedConstraintList<Tells_exportedConstraint>();

	/**
	 * Adds the given {@link Tells_exportedConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells_exported(Tells_exportedConstraint constraint) {
		{
			$$tells_exportedHashIndex_0_StorageKey list;
			$$tells_exportedHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$tells_exportedHashIndex_0.insertOrGet($$tells_exportedHashIndex_0_StorageKey)) == null) {
				$$tells_exportedHashIndex_0_StorageKey.addFirst(constraint);
				$$tells_exportedHashIndex_0_StorageKey = new $$tells_exportedHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$tells_exportedConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<Tells_exportedConstraint> lookupTells_exported_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tells_exportedHashIndex_0_LookupKey_0.init($0_value);
		return $$tells_exportedHashIndex_0.get($$tells_exportedHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<Tells_exportedConstraint> lookupTells_exported_1_0() {
		return $$tells_exportedConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Tells_exportedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Tells_exportedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Tells_exportedConstraint> lookupTells_exported() {
		return $$tells_exportedConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Tells_exportedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells_exported()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells_exported
	 */
	Iterable<Tells_exportedConstraint> getTells_exportedConstraints(Filter<? super Tells_exportedConstraint> filter) {
		return new FilteredIterable<Tells_exportedConstraint>($$tells_exportedConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Tells_exportedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells_exported</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Tells_exportedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells_exported
	 */
	Collection<Tells_exportedConstraint> getTells_exportedConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<Tells_exportedConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<Tells_exportedConstraint> iterator() {
				return lookupTells_exported();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Tells_exportedConstraint</code>.
	 */
	void reactivateTells_exportedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Tells_exportedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTells_exportedConstraints(util.iterator.Filtered.Filter<? super Tells_exportedConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		terminateAll($$reactivatesConstraintList);
		terminateAll($$reactiveConstraintList);
		{
			Iterator<? extends runtime.DoublyLinkedConstraintList<TellsConstraint>> outer = $$tellsHashIndex_0.iterator();
			while (outer.hasNext()) terminateAll(outer.next());
		}
		terminateAll($$exportedConstraintList);
		terminateAll($$recursiveHashIndex_0.iterator());
		terminateAll($$tells_exportedConstraintList);
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.136+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "reactivates",
		arity = 1,
		fields = {"$0"}
	)
	final class ReactivatesConstraint extends Constraint {
		ReactivatesConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeReactivates(ReactivatesConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "reactivates";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation reactivates_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			RecursiveConstraint recursive_6;
			recursive_6 = lookupRecursive_0_0(X);
			if (recursive_6 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation reactivates_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<ReactiveConstraint> reactive_1_lookup;
			reactive_1_lookup = lookupReactive_0_0();
			Iterator<ReactiveConstraint> reactive_1_iter;
			reactive_1_iter = reactive_1_lookup.semiUniversalIterator();
			ReactiveConstraint reactive_1;
			while (reactive_1_iter.hasNext()) {
				reactive_1 = reactive_1_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = reactive_1.$0;
				stored = true;
				ID = IDcounter++;
				storeReactivates(ReactivatesConstraint.this);

				if (reactive_1_iter.hasNext()) {
					$$continuationStack.push(new Reactivates_2_1(reactive_1_iter));
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = reactivates_1()) != null) return continuation;
				if ((continuation = reactivates_2()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeReactivates(ReactivatesConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Reactivates_2_1 extends Continuation {
			private final Iterator<ReactiveConstraint> reactive_1_iter;

			public Reactivates_2_1(Iterator<ReactiveConstraint> reactive_1_iter) {
				this.reactive_1_iter = reactive_1_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = reactivates_2_1(reactive_1_iter)) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Reactivates_2_1")
					.append('(')
					.append("reactive_1_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation reactivates_2_1(Iterator<ReactiveConstraint> reactive_1_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			ReactiveConstraint reactive_1;
			do {
				reactive_1 = reactive_1_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = reactive_1.$0;
				if (reactive_1_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new TellsConstraint(X, Y);
			} while (reactive_1_iter.hasNext());
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("reactivates(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.ReactivatesConstraint)
			    && this.equals((ReactivatesConstraint)other);
		}

		public boolean equals(ReactivatesConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -1157626611;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.138+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "cons",
		arity = 1,
		fields = {"$0"}
	)
	final class ConsConstraint extends Continuation implements IConstraint {
		ConsConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "cons";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation cons_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			if (X.isReactive()) {
				$$continuationStack.push(
					new Cons_2()
				);
				return new ReactiveConstraint(X);
			}
			return null;
		}

		protected final Continuation cons_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			if (compiler.CHRIntermediateForm.modifiers.Modifier.isExported(X)) {
				$$continuationStack.push(
					new Cons_3()
				);
				return new ExportedConstraint(X);
			}
			return null;
		}

		protected final Continuation cons_3() {
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = cons_1()) != null) return continuation;
				if ((continuation = cons_2()) != null) return continuation;
				if ((continuation = cons_3()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		protected final class Cons_2 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = cons_2()) != null) return continuation;
				if ((continuation = cons_3()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Cons_2()";
			}
		}

		protected final class Cons_3 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = cons_3()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Cons_3()";
			}
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("cons(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.ConsConstraint)
			    && this.equals((ConsConstraint)other);
		}

		public boolean equals(ConsConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 3059505;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.140+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "reactive",
		arity = 1,
		fields = {"$0"}
	)
	public  final class ReactiveConstraint extends Constraint {
		ReactiveConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeReactive(ReactiveConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
			}
		}

		public final String getIdentifier() {
			return "reactive";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation reactive_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<ReactivatesConstraint> reactivates_2_lookup;
			reactivates_2_lookup = lookupReactivates_1_0();
			Iterator<ReactivatesConstraint> reactivates_2_iter;
			reactivates_2_iter = reactivates_2_lookup.universalIterator();
			ReactivatesConstraint reactivates_2;
			while (reactivates_2_iter.hasNext()) {
				reactivates_2 = reactivates_2_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = reactivates_2.$0;
				if (reactivates_2_iter.hasNext()) {
					$$continuationStack.push(new Reactive_1_1(reactivates_2_iter));
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		protected Continuation call() {
			Continuation continuation;
			if ((continuation = reactive_1()) != null) return continuation;
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeReactive(ReactiveConstraint.this);
			}
			return $$continuationStack.pop();
		}


		protected final class Reactive_1_1 extends Continuation {
			private final Iterator<ReactivatesConstraint> reactivates_2_iter;

			public Reactive_1_1(Iterator<ReactivatesConstraint> reactivates_2_iter) {
				this.reactivates_2_iter = reactivates_2_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = reactive_1_1(reactivates_2_iter)) != null) return continuation;
				store();
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Reactive_1_1")
					.append('(')
					.append("reactivates_2_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation reactive_1_1(Iterator<ReactivatesConstraint> reactivates_2_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			ReactivatesConstraint reactivates_2;
			while (reactivates_2_iter.hasNext()) {
				reactivates_2 = reactivates_2_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = reactivates_2.$0;
				if (reactivates_2_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("reactive(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.ReactiveConstraint)
			    && this.equals((ReactiveConstraint)other);
		}

		public boolean equals(ReactiveConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -867509511;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.142+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class TellsConstraint extends Constraint implements Key {
		TellsConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$1() { return this.$1; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells(TellsConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_8_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tellsHashIndex_1.remove(this);
			}
		}

		public final String getIdentifier() {
			return "tells";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$$rule_8_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation tells_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			RecursiveConstraint recursive_3;
			recursive_3 = lookupRecursive_0_0(X);
			if (recursive_3 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $131 = this.$1;
			if ($131.equals(X)) {
				this.terminate();
				return new RecursiveConstraint(X);
			}
			return null;
		}

		protected final Continuation tells_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			TellsConstraint tells_4;
			tells_4 = lookupTells_1_0(X, Y);
			if (tells_4 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			RecursiveConstraint recursive_4;
			recursive_4 = lookupRecursive_0_0(Y);
			if (recursive_4 != null) {
				this.terminate();
				return new RecursiveConstraint(X);
			}
			return null;
		}

		protected final Continuation tells_6() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_7_lookup;
			tells_7_lookup = lookupTells_2_0(Y);
			if (tells_7_lookup != null) {
				Iterator<TellsConstraint> tells_7_iter;
				tells_7_iter = tells_7_lookup.universalIterator();
				TellsConstraint tells_7;
				while (tells_7_iter.hasNext()) {
					tells_7 = tells_7_iter.next();
					if (this != tells_7) {
						if (!stored || !(tells_7.$$$rule_8_history.contains(-this.ID)
							|| !$$$rule_8_history.insert(tells_7.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_7.$0;
							stored = true;
							ID = IDcounter++;
							int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
							hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
							hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
							this.hashCode = hashCode;
							storeTells(TellsConstraint.this);

							$$$rule_8_history.add(tells_7.ID);
							if (tells_7_iter.hasNext()) {
								$$continuationStack.push(new Tells_6_1(tells_7_iter));
							} else {
								$$continuationStack.push(new Tells_7());
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation tells_7() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_6_lookup;
			tells_6_lookup = lookupTells_0_0(Y);
			if (tells_6_lookup != null) {
				Iterator<TellsConstraint> tells_6_iter;
				tells_6_iter = tells_6_lookup.universalIterator();
				TellsConstraint tells_6;
				while (tells_6_iter.hasNext()) {
					tells_6 = tells_6_iter.next();
					if (this != tells_6) {
						if (!stored || !(tells_6.$$$rule_8_history.contains(this.ID)
							|| !$$$rule_8_history.insert(-tells_6.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_6.$1;
							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeTells(TellsConstraint.this);
							}

							$$$rule_8_history.add(-tells_6.ID);
							if (tells_6_iter.hasNext()) {
								$$continuationStack.push(new Tells_7_1(tells_6_iter));
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_1()) != null) return continuation;
				if ((continuation = tells_2()) != null) return continuation;
				if ((continuation = tells_3()) != null) return continuation;
				if ((continuation = tells_5()) != null) return continuation;
				if ((continuation = tells_6()) != null) return continuation;
				if ((continuation = tells_7()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells(TellsConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_6_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_7_iter;

			public Tells_6_1(Iterator<TellsConstraint> tells_7_iter) {
				this.tells_7_iter = tells_7_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_6_1(tells_7_iter)) != null) return continuation;
					if ((continuation = tells_7()) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_6_1")
					.append('(')
					.append("tells_7_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_6_1(Iterator<TellsConstraint> tells_7_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			TellsConstraint tells_7;
			while (tells_7_iter.hasNext()) {
				tells_7 = tells_7_iter.next();
				if (this != tells_7) {
					if (!stored || !(tells_7.$$$rule_8_history.contains(-this.ID)
						|| !$$$rule_8_history.insert(tells_7.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_7.$0;
						$$$rule_8_history.add(tells_7.ID);
						if (tells_7_iter.hasNext()) {
							$$continuationStack.undoPop();
						} else {
							$$continuationStack.push(new Tells_7());
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		protected final class Tells_7 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_7()) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_7()";
			}
		}

		protected final class Tells_7_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_6_iter;

			public Tells_7_1(Iterator<TellsConstraint> tells_6_iter) {
				this.tells_6_iter = tells_6_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_7_1(tells_6_iter)) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_7_1")
					.append('(')
					.append("tells_6_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_7_1(Iterator<TellsConstraint> tells_6_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			TellsConstraint tells_6;
			while (tells_6_iter.hasNext()) {
				tells_6 = tells_6_iter.next();
				if (this != tells_6) {
					if (!stored || !(tells_6.$$$rule_8_history.contains(this.ID)
						|| !$$$rule_8_history.insert(-tells_6.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_6.$1;
						$$$rule_8_history.add(-tells_6.ID);
						if (tells_6_iter.hasNext()) {
							$$continuationStack.undoPop();
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.TellsConstraint)
			    && this.equals((TellsConstraint)other);
		}

		public boolean equals(TellsConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.150+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "exported",
		arity = 1,
		fields = {"$0"}
	)
	final class ExportedConstraint extends Constraint {
		ExportedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeExported(ExportedConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
			}
		}

		public final String getIdentifier() {
			return "exported";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation exported_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_2_lookup;
			tells_exported_2_lookup = lookupTells_exported_1_0();
			Iterator<Tells_exportedConstraint> tells_exported_2_iter;
			tells_exported_2_iter = tells_exported_2_lookup.universalIterator();
			Tells_exportedConstraint tells_exported_2;
			while (tells_exported_2_iter.hasNext()) {
				tells_exported_2 = tells_exported_2_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_2.$0;
				if (tells_exported_2_iter.hasNext()) {
					$$continuationStack.push(new Exported_1_1(tells_exported_2_iter));
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		protected Continuation call() {
			Continuation continuation;
			if ((continuation = exported_1()) != null) return continuation;
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeExported(ExportedConstraint.this);
			}
			return $$continuationStack.pop();
		}


		protected final class Exported_1_1 extends Continuation {
			private final Iterator<Tells_exportedConstraint> tells_exported_2_iter;

			public Exported_1_1(Iterator<Tells_exportedConstraint> tells_exported_2_iter) {
				this.tells_exported_2_iter = tells_exported_2_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = exported_1_1(tells_exported_2_iter)) != null) return continuation;
				store();
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Exported_1_1")
					.append('(')
					.append("tells_exported_2_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation exported_1_1(Iterator<Tells_exportedConstraint> tells_exported_2_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			Tells_exportedConstraint tells_exported_2;
			while (tells_exported_2_iter.hasNext()) {
				tells_exported_2 = tells_exported_2_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_2.$0;
				if (tells_exported_2_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("exported(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.ExportedConstraint)
			    && this.equals((ExportedConstraint)other);
		}

		public boolean equals(ExportedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -1926036653;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.152+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "is_recursive",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class Is_recursiveConstraint extends Continuation implements IConstraint {
		Is_recursiveConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, runtime.BooleanAnswer $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final runtime.BooleanAnswer $1;
		public runtime.BooleanAnswer get$1() { return this.$1; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "is_recursive";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				runtime.BooleanAnswer.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation is_recursive_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.BooleanAnswer B = this.$1;
			RecursiveConstraint recursive_7;
			recursive_7 = lookupRecursive_0_0(X);
			if (recursive_7 != null) {
				$solver_0.tellEqual(B, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation is_recursive_2() {
			runtime.BooleanAnswer B = this.$1;
			$solver_0.tellEqual(B, false);
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = is_recursive_1()) != null) return continuation;
				if ((continuation = is_recursive_2()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("is_recursive(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.Is_recursiveConstraint)
			    && this.equals((Is_recursiveConstraint)other);
		}

		public boolean equals(Is_recursiveConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -145326243;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.154+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "recursive",
		arity = 1,
		fields = {"$0"}
	)
	final class RecursiveConstraint extends Constraint implements Key {
		RecursiveConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeRecursive(RecursiveConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$recursiveHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "recursive";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation recursive_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			RecursiveConstraint recursive_2;
			recursive_2 = lookupRecursive_0_0(X);
			if (recursive_2 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation recursive_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_1_lookup;
			tells_1_lookup = lookupTells_0_0(X);
			if (tells_1_lookup != null) {
				Iterator<TellsConstraint> tells_1_iter;
				tells_1_iter = tells_1_lookup.semiUniversalIterator();
				TellsConstraint tells_1;
				while (tells_1_iter.hasNext()) {
					tells_1 = tells_1_iter.next();
					tells_1.terminate();
				}
			}
			return null;
		}

		protected final Continuation recursive_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_5_lookup;
			tells_5_lookup = lookupTells_2_0(Y);
			if (tells_5_lookup != null) {
				Iterator<TellsConstraint> tells_5_iter;
				tells_5_iter = tells_5_lookup.universalIterator();
				TellsConstraint tells_5;
				while (tells_5_iter.hasNext()) {
					tells_5 = tells_5_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_5.$0;
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeRecursive(RecursiveConstraint.this);

					tells_5.terminate();
					if (tells_5_iter.hasNext()) {
						$$continuationStack.push(new Recursive_4_1(tells_5_iter));
					} else {
						$$continuationStack.push(new Recursive_5());
					}
					return new RecursiveConstraint(X);
				}
			}
			return null;
		}

		protected final Continuation recursive_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_1_lookup;
			tells_exported_1_lookup = lookupTells_exported_0_0(X);
			if (tells_exported_1_lookup != null) {
				Iterator<Tells_exportedConstraint> tells_exported_1_iter;
				tells_exported_1_iter = tells_exported_1_lookup.semiUniversalIterator();
				Tells_exportedConstraint tells_exported_1;
				while (tells_exported_1_iter.hasNext()) {
					tells_exported_1 = tells_exported_1_iter.next();
					tells_exported_1.terminate();
				}
			}
			return null;
		}

		protected final Continuation recursive_6() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<ReactivatesConstraint> reactivates_1_lookup;
			reactivates_1_lookup = lookupReactivates_0_0(X);
			if (reactivates_1_lookup != null) {
				Iterator<ReactivatesConstraint> reactivates_1_iter;
				reactivates_1_iter = reactivates_1_lookup.semiUniversalIterator();
				ReactivatesConstraint reactivates_1;
				while (reactivates_1_iter.hasNext()) {
					reactivates_1 = reactivates_1_iter.next();
					reactivates_1.terminate();
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = recursive_1()) != null) return continuation;
				if ((continuation = recursive_3()) != null) return continuation;
				if ((continuation = recursive_4()) != null) return continuation;
				if ((continuation = recursive_5()) != null) return continuation;
				if ((continuation = recursive_6()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeRecursive(RecursiveConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Recursive_4_1 extends Continuation {
			private final Iterator<TellsConstraint> tells_5_iter;

			public Recursive_4_1(Iterator<TellsConstraint> tells_5_iter) {
				this.tells_5_iter = tells_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = recursive_4_1(tells_5_iter)) != null) return continuation;
				if ((continuation = recursive_5()) != null) return continuation;
				if ((continuation = recursive_6()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Recursive_4_1")
					.append('(')
					.append("tells_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation recursive_4_1(Iterator<TellsConstraint> tells_5_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			TellsConstraint tells_5;
			while (tells_5_iter.hasNext()) {
				tells_5 = tells_5_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_5.$0;
				tells_5.terminate();
				if (tells_5_iter.hasNext()) {
					$$continuationStack.undoPop();
				} else {
					$$continuationStack.push(new Recursive_5());
				}
				return new RecursiveConstraint(X);
			}
			return null;
		}

		protected final class Recursive_5 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = recursive_5()) != null) return continuation;
				if ((continuation = recursive_6()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Recursive_5()";
			}
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("recursive(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.RecursiveConstraint)
			    && this.equals((RecursiveConstraint)other);
		}

		public boolean equals(RecursiveConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.157+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells_exported",
		arity = 1,
		fields = {"$0"}
	)
	final class Tells_exportedConstraint extends Constraint {
		Tells_exportedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeTells_exported(Tells_exportedConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "tells_exported";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RecursionHandler getHandler() {
			return RecursionHandler.this;
		}

		protected final Continuation tells_exported_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			RecursiveConstraint recursive_5;
			recursive_5 = lookupRecursive_0_0(X);
			if (recursive_5 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_exported_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<ExportedConstraint> exported_1_lookup;
			exported_1_lookup = lookupExported_0_0();
			Iterator<ExportedConstraint> exported_1_iter;
			exported_1_iter = exported_1_lookup.semiUniversalIterator();
			ExportedConstraint exported_1;
			while (exported_1_iter.hasNext()) {
				exported_1 = exported_1_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = exported_1.$0;
				stored = true;
				ID = IDcounter++;
				storeTells_exported(Tells_exportedConstraint.this);

				if (exported_1_iter.hasNext()) {
					$$continuationStack.push(new Tells_exported_2_1(exported_1_iter));
				}
				return new TellsConstraint(X, Y);
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_exported_1()) != null) return continuation;
				if ((continuation = tells_exported_2()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeTells_exported(Tells_exportedConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_exported_2_1 extends Continuation {
			private final Iterator<ExportedConstraint> exported_1_iter;

			public Tells_exported_2_1(Iterator<ExportedConstraint> exported_1_iter) {
				this.exported_1_iter = exported_1_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_exported_2_1(exported_1_iter)) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_exported_2_1")
					.append('(')
					.append("exported_1_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_exported_2_1(Iterator<ExportedConstraint> exported_1_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			ExportedConstraint exported_1;
			do {
				exported_1 = exported_1_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = exported_1.$0;
				if (exported_1_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new TellsConstraint(X, Y);
			} while (exported_1_iter.hasNext());
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells_exported(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RecursionHandler.Tells_exportedConstraint)
			    && this.equals((Tells_exportedConstraint)other);
		}

		public boolean equals(Tells_exportedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + $0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + -785113072;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == ReactivatesConstraint.class)
			return true;
		if (constraintClass == ConsConstraint.class)
			return false;
		if (constraintClass == ReactiveConstraint.class)
			return true;
		if (constraintClass == TellsConstraint.class)
			return true;
		if (constraintClass == ExportedConstraint.class)
			return true;
		if (constraintClass == Is_recursiveConstraint.class)
			return false;
		if (constraintClass == RecursiveConstraint.class)
			return true;
		if (constraintClass == Tells_exportedConstraint.class)
			return true;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
