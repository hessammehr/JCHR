/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package compiler.analysis.observation;

import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2008-03-10T10:38:15.84+01:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "activates",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "observes",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "observed",
		arity = 3
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
class ObservationHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	final runtime.PrimitiveAnswerSolver $solver_0;

	public ObservationHandler(runtime.PrimitiveAnswerSolver $solver_0) {
		this($solver_0, runtime.ConstraintSystem.get());
	}

	public ObservationHandler(runtime.PrimitiveAnswerSolver $solver_0, runtime.ConstraintSystem $$constraintSystem) {
		super($$constraintSystem);
		$$continuationStack = getContinuationStack();
		this.$solver_0 = $solver_0;
	}

	@Override
	public String getIdentifier() {
		return "observation";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			ActivatesConstraint.class, 
			ObservesConstraint.class, 
			ObservedConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupActivates()
	 * @see #lookupObserves()
	 * @see #lookupObserved()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupActivates(),
			lookupObserves()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupActivates()
	 * @see #lookupObserves()
	 * @see #lookupObserved()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupActivates(),
			lookupObserves()
		);
	}

	ObservationHandler includePackage() {
		return this;
	}
	protected ObservationHandler includeProtected() {
		return this;
	}

	@JCHR_Tells(
		constraint = "activates",
		warrantsStackOpimization = true
	)
	final void tellActivates(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ActivatesConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ActivatesConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new ActivatesConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "observes",
		warrantsStackOpimization = true
	)
	final void tellObserves(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observor, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observee) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ObservesConstraint(Observor, Observee));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ObservesConstraint(Observor, Observee));
		else
			$$continuationQueue.enqueue(new ObservesConstraint(Observor, Observee));
	}

	@JCHR_Tells(
		constraint = "observed",
		warrantsStackOpimization = true
	)
	final void tellObserved(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1, runtime.BooleanAnswer $2) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ObservedConstraint($0, $1, $2));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ObservedConstraint($0, $1, $2));
		else
			$$continuationQueue.enqueue(new ObservedConstraint($0, $1, $2));
	}

	protected final HashIndex<ActivatesConstraint> $$activatesHashIndex_0 = new HashIndex<ActivatesConstraint>();

	private final class $$activatesHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$activatesHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$activatesHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((ActivatesConstraint)other).get$0().equals(this.X0) &&
				((ActivatesConstraint)other).get$1().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$activatesHashIndex_0_LookupKey_0 $$activatesHashIndex_0_LookupKey_0 = new $$activatesHashIndex_0_LookupKey_0();

	final HashIndex<$$activatesHashIndex_1_StorageKey> $$activatesHashIndex_1 = new HashIndex<$$activatesHashIndex_1_StorageKey>();

	private final static class $$activatesHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$activatesHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$activatesHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$activatesHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$activatesHashIndex_1_LookupKey_0 $$activatesHashIndex_1_LookupKey_0 = new $$activatesHashIndex_1_LookupKey_0();

	private final static class $$activatesHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<ActivatesConstraint>
		implements Cloneable<$$activatesHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$activatesHashIndex_1_StorageKey() {
			// NOP
		}

		public $$activatesHashIndex_1_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$activatesHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$activatesHashIndex_1_StorageKey clone() {
			try {
				return ($$activatesHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$activatesHashIndex_1_StorageKey $$activatesHashIndex_1_StorageKey = new $$activatesHashIndex_1_StorageKey();

	/**
	 * Adds the given {@link ActivatesConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeActivates(ActivatesConstraint constraint) {
		$$activatesHashIndex_0.putFirstTime(constraint);
		{
			$$activatesHashIndex_1_StorageKey list;
			$$activatesHashIndex_1_StorageKey.init(
				constraint.get$1()
			);
			if ((list = $$activatesHashIndex_1.insertOrGet($$activatesHashIndex_1_StorageKey)) == null) {
				$$activatesHashIndex_1_StorageKey.addFirst(constraint);
				$$activatesHashIndex_1_StorageKey = new $$activatesHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
	}

	final ActivatesConstraint lookupActivates_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$activatesHashIndex_0_LookupKey_0.init($0_value,$1_value);
		return $$activatesHashIndex_0.get($$activatesHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<ActivatesConstraint> lookupActivates_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$activatesHashIndex_1_LookupKey_0.init($1_value);
		return $$activatesHashIndex_1.get($$activatesHashIndex_1_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>ActivatesConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ActivatesConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ActivatesConstraint> lookupActivates() {
		return $$activatesHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ActivatesConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupActivates()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupActivates
	 */
	Iterable<ActivatesConstraint> getActivatesConstraints(Filter<? super ActivatesConstraint> filter) {
		return new FilteredIterable<ActivatesConstraint>(
			$$activatesHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ActivatesConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupActivates</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ActivatesConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupActivates
	 */
	Collection<ActivatesConstraint> getActivatesConstraints()
 {
		return new AbstractUnmodifiableCollection<ActivatesConstraint>() {
			@Override
			public int size() {
				return $$activatesHashIndex_0.size();
			}

			@Override
			public Iterator<ActivatesConstraint> iterator() {
				return lookupActivates();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ActivatesConstraint</code>.
	 */
	void reactivateActivatesConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ActivatesConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateActivatesConstraints(util.iterator.Filtered.Filter<? super ActivatesConstraint> filter) {
		// NOP
	}

	protected final HashIndex<ObservesConstraint> $$observesHashIndex_0 = new HashIndex<ObservesConstraint>();

	private final class $$observesHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$observesHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$observesHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((ObservesConstraint)other).getObservor().equals(this.X0) &&
				((ObservesConstraint)other).getObservee().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$observesHashIndex_0_LookupKey_0 $$observesHashIndex_0_LookupKey_0 = new $$observesHashIndex_0_LookupKey_0();

	final HashIndex<$$observesHashIndex_1_StorageKey> $$observesHashIndex_1 = new HashIndex<$$observesHashIndex_1_StorageKey>();

	private final static class $$observesHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$observesHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$observesHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$observesHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$observesHashIndex_1_LookupKey_0 $$observesHashIndex_1_LookupKey_0 = new $$observesHashIndex_1_LookupKey_0();

	private final static class $$observesHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<ObservesConstraint>
		implements Cloneable<$$observesHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$observesHashIndex_1_StorageKey() {
			// NOP
		}

		public $$observesHashIndex_1_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$observesHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$observesHashIndex_1_StorageKey clone() {
			try {
				return ($$observesHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$observesHashIndex_1_StorageKey $$observesHashIndex_1_StorageKey = new $$observesHashIndex_1_StorageKey();

	/**
	 * Adds the given {@link ObservesConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeObserves(ObservesConstraint constraint) {
		$$observesHashIndex_0.putFirstTime(constraint);
		{
			$$observesHashIndex_1_StorageKey list;
			$$observesHashIndex_1_StorageKey.init(
				constraint.getObservor()
			);
			if ((list = $$observesHashIndex_1.insertOrGet($$observesHashIndex_1_StorageKey)) == null) {
				$$observesHashIndex_1_StorageKey.addFirst(constraint);
				$$observesHashIndex_1_StorageKey = new $$observesHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
	}

	final ObservesConstraint lookupObserves_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observor_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observee_value) {
		$$observesHashIndex_0_LookupKey_0.init(Observor_value,Observee_value);
		return $$observesHashIndex_0.get($$observesHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<ObservesConstraint> lookupObserves_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observor_value) {
		$$observesHashIndex_1_LookupKey_0.init(Observor_value);
		return $$observesHashIndex_1.get($$observesHashIndex_1_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>ObservesConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ObservesConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ObservesConstraint> lookupObserves() {
		return $$observesHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ObservesConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupObserves()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupObserves
	 */
	Iterable<ObservesConstraint> getObservesConstraints(Filter<? super ObservesConstraint> filter) {
		return new FilteredIterable<ObservesConstraint>(
			$$observesHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ObservesConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupObserves</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ObservesConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupObserves
	 */
	Collection<ObservesConstraint> getObservesConstraints()
 {
		return new AbstractUnmodifiableCollection<ObservesConstraint>() {
			@Override
			public int size() {
				return $$observesHashIndex_0.size();
			}

			@Override
			public Iterator<ObservesConstraint> iterator() {
				return lookupObserves();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ObservesConstraint</code>.
	 */
	void reactivateObservesConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ObservesConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateObservesConstraints(util.iterator.Filtered.Filter<? super ObservesConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>ObservedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ObservedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ObservedConstraint> lookupObserved() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ObservedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupObserved()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupObserved
	 */
	Iterable<ObservedConstraint> getObservedConstraints(Filter<? super ObservedConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ObservedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupObserved</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ObservedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupObserved
	 */
	Collection<ObservedConstraint> getObservedConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>ObservedConstraint</code>.
	 */
	void reactivateObservedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ObservedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateObservedConstraints(util.iterator.Filtered.Filter<? super ObservedConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		terminateAll($$activatesHashIndex_0.iterator());
		terminateAll($$observesHashIndex_0.iterator());
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.99+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "activates",
		arity = 2,
		fields = {"$0", "$1"}
	)
	final class ActivatesConstraint extends Constraint implements Key {
		ActivatesConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$1() { return this.$1; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeActivates(ActivatesConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$indirect_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$activatesHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "activates";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final ObservationHandler getHandler() {
			return ObservationHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$indirect_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation activates_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			ActivatesConstraint activates_2;
			activates_2 = lookupActivates_0_0(X, Y);
			if (activates_2 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation activates_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.ConstraintIterable<ObservesConstraint> observes_3_lookup;
			observes_3_lookup = lookupObserves_1_0(Y);
			if (observes_3_lookup != null) {
				Iterator<ObservesConstraint> observes_3_iter;
				observes_3_iter = observes_3_lookup.semiUniversalIterator();
				ObservesConstraint observes_3;
				while (observes_3_iter.hasNext()) {
					observes_3 = observes_3_iter.next();
					if (!stored || !(observes_3.$$indirect_history.contains(this.ID)
						|| !$$indirect_history.insert(observes_3.getConstraintId()))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = observes_3.Observee;
						stored = true;
						ID = IDcounter++;
						int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
						hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
						hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
						this.hashCode = hashCode;
						storeActivates(ActivatesConstraint.this);

						$$indirect_history.add(observes_3.getConstraintId());
						if (observes_3_iter.hasNext()) {
							$$continuationStack.push(new Activates_3_1(observes_3_iter));
						}
						return new ObservesConstraint(X, Z);
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = activates_1()) != null) return continuation;
				if ((continuation = activates_3()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeActivates(ActivatesConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Activates_3_1 extends Continuation {
			private final Iterator<ObservesConstraint> observes_3_iter;

			public Activates_3_1(Iterator<ObservesConstraint> observes_3_iter) {
				this.observes_3_iter = observes_3_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = activates_3_1(observes_3_iter)) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Activates_3_1")
					.append('(')
					.append("observes_3_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation activates_3_1(Iterator<ObservesConstraint> observes_3_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			ObservesConstraint observes_3;
			do {
				observes_3 = observes_3_iter.next();
				if (!stored || !(observes_3.$$indirect_history.contains(this.ID)
					|| !$$indirect_history.insert(observes_3.getConstraintId()))) {
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = observes_3.Observee;
					$$indirect_history.add(observes_3.getConstraintId());
					if (observes_3_iter.hasNext()) {
						$$continuationStack.undoPop();
					}
					return new ObservesConstraint(X, Z);
				}
			} while (observes_3_iter.hasNext());
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("activates(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof ObservationHandler.ActivatesConstraint)
			    && this.equals((ActivatesConstraint)other);
		}

		public boolean equals(ActivatesConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.102+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "observes",
		arity = 2,
		fields = {"Observor", "Observee"}
	)
	final class ObservesConstraint extends Constraint implements Key {
		ObservesConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observor, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observee) {
			this.Observor = Observor;
			this.Observee = Observee;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observor;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint getObservor() { return this.Observor; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Observee;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint getObservee() { return this.Observee; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + Observor.hashCode()) + Observee.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeObserves(ObservesConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$indirect_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$observesHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "observes";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				getObservor(),
				getObservee()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final ObservationHandler getHandler() {
			return ObservationHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$indirect_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation observes_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.Observor;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Observee;
			ObservesConstraint observes_2;
			observes_2 = lookupObserves_0_0(X, Y);
			if (observes_2 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation observes_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Observor;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.Observee;
			runtime.ConstraintIterable<ActivatesConstraint> activates_3_lookup;
			activates_3_lookup = lookupActivates_1_0(Y);
			if (activates_3_lookup != null) {
				Iterator<ActivatesConstraint> activates_3_iter;
				activates_3_iter = activates_3_lookup.semiUniversalIterator();
				ActivatesConstraint activates_3;
				while (activates_3_iter.hasNext()) {
					activates_3 = activates_3_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = activates_3.$0;
					stored = true;
					ID = IDcounter++;
					$$indirect_history.add(activates_3.getConstraintId());
					int hashCode = 37 * (37 * (23) + Observor.hashCode()) + Observee.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeObserves(ObservesConstraint.this);

					if (activates_3_iter.hasNext()) {
						$$continuationStack.push(new Observes_3_1(activates_3_iter));
					}
					return new ObservesConstraint(X, Z);
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = observes_1()) != null) return continuation;
				if ((continuation = observes_3()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + Observor.hashCode()) + Observee.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeObserves(ObservesConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Observes_3_1 extends Continuation {
			private final Iterator<ActivatesConstraint> activates_3_iter;

			public Observes_3_1(Iterator<ActivatesConstraint> activates_3_iter) {
				this.activates_3_iter = activates_3_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = observes_3_1(activates_3_iter)) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Observes_3_1")
					.append('(')
					.append("activates_3_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation observes_3_1(Iterator<ActivatesConstraint> activates_3_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Observor;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.Observee;
			ActivatesConstraint activates_3;
			do {
				activates_3 = activates_3_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = activates_3.$0;
				if (activates_3_iter.hasNext()) {
					$$continuationStack.undoPop();
				}
				return new ObservesConstraint(X, Z);
			} while (activates_3_iter.hasNext());
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("observes(")
				.append(Observor)
				.append(", ")
				.append(Observee)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof ObservationHandler.ObservesConstraint)
			    && this.equals((ObservesConstraint)other);
		}

		public boolean equals(ObservesConstraint other) {
			if (this == other) return true;
			return this.Observor.equals(other.Observor)
			    && this.Observee.equals(other.Observee);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + Observor.hashCode()) + Observee.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:15.105+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "observed",
		arity = 3,
		fields = {"$0", "$1", "$2"}
	)
	final class ObservedConstraint extends Continuation implements IConstraint {
		ObservedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1, runtime.BooleanAnswer $2) {
			this.$0 = $0;
			this.$1 = $1;
			this.$2 = $2;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$1() { return this.$1; }

		final runtime.BooleanAnswer $2;
		public runtime.BooleanAnswer get$2() { return this.$2; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "observed";
		}

		public final int getArity() {
			return 3;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1(),
				get$2()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				runtime.BooleanAnswer.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final ObservationHandler getHandler() {
			return ObservationHandler.this;
		}

		protected final Continuation observed_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.BooleanAnswer Answer = this.$2;
			ObservesConstraint observes_4;
			observes_4 = lookupObserves_0_0(X, Y);
			if (observes_4 != null) {
				$solver_0.tellEqual(Answer, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation observed_2() {
			runtime.BooleanAnswer Answer = this.$2;
			$solver_0.tellEqual(Answer, false);
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = observed_1()) != null) return continuation;
				if ((continuation = observed_2()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("observed(")
				.append($0)
				.append(", ")
				.append($1)
				.append(", ")
				.append($2)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof ObservationHandler.ObservedConstraint)
			    && this.equals((ObservedConstraint)other);
		}

		public boolean equals(ObservedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1)
			    && this.$2.equals(other.$2);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (37 * (37 * (23) + $0.hashCode()) + $1.hashCode()) + $2.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 348607176;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == ActivatesConstraint.class)
			return true;
		if (constraintClass == ObservesConstraint.class)
			return true;
		if (constraintClass == ObservedConstraint.class)
			return false;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
