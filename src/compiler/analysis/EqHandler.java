/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package compiler.analysis;

import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2008-03-10T10:38:16.684+01:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "eq",
		arity = 2,
		infix = "="
	),
	@JCHR_Constraint(
		identifier = "ask",
		arity = 3
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
public class EqHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	final runtime.PrimitiveAnswerSolver $solver_0;

	public EqHandler(runtime.PrimitiveAnswerSolver $solver_0) {
		this($solver_0, runtime.ConstraintSystem.get());
	}

	public EqHandler(runtime.PrimitiveAnswerSolver $solver_0, runtime.ConstraintSystem $$constraintSystem) {
		super($$constraintSystem);
		$$continuationStack = getContinuationStack();
		this.$solver_0 = $solver_0;
	}

	@Override
	public String getIdentifier() {
		return "eq";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			EqConstraint.class, 
			AskConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupEq()
	 * @see #lookupAsk()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupEq()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupEq()
	 * @see #lookupAsk()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupEq()
		);
	}

	EqHandler includePackage() {
		return this;
	}
	protected EqHandler includeProtected() {
		return this;
	}

	@JCHR_Tells(
		constraint = "eq",
		warrantsStackOpimization = true
	)
	public final void tellEq(compiler.CHRIntermediateForm.arg.argument.IArgument $0, compiler.CHRIntermediateForm.arg.argument.IArgument $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new EqConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new EqConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new EqConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "ask",
		warrantsStackOpimization = true
	)
	public final void tellAsk(compiler.CHRIntermediateForm.arg.argument.IArgument $0, compiler.CHRIntermediateForm.arg.argument.IArgument $1, runtime.BooleanAnswer Result) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new AskConstraint($0, $1, Result));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new AskConstraint($0, $1, Result));
		else
			$$continuationQueue.enqueue(new AskConstraint($0, $1, Result));
	}

	protected final HashIndex<EqConstraint> $$eqHashIndex_0 = new HashIndex<EqConstraint>();

	private final class $$eqHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X0;
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X1;
		private int hashCode;

		public $$eqHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$eqHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.arg.argument.IArgument X0, compiler.CHRIntermediateForm.arg.argument.IArgument X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.arg.argument.IArgument X0, compiler.CHRIntermediateForm.arg.argument.IArgument X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((EqConstraint)other).get$0().equals(this.X0) &&
				((EqConstraint)other).get$1().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$eqHashIndex_0_LookupKey_0 $$eqHashIndex_0_LookupKey_0 = new $$eqHashIndex_0_LookupKey_0();

	final HashIndex<$$eqHashIndex_1_StorageKey> $$eqHashIndex_1 = new HashIndex<$$eqHashIndex_1_StorageKey>();

	private final static class $$eqHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X0;
		private int hashCode;

		public $$eqHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$eqHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$eqHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$eqHashIndex_1_LookupKey_0 $$eqHashIndex_1_LookupKey_0 = new $$eqHashIndex_1_LookupKey_0();

	private final static class $$eqHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<EqConstraint>
		implements Cloneable<$$eqHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X0;
		private int hashCode;

		public $$eqHashIndex_1_StorageKey() {
			// NOP
		}

		public $$eqHashIndex_1_StorageKey(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$eqHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$eqHashIndex_1_StorageKey clone() {
			try {
				return ($$eqHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$eqHashIndex_1_StorageKey $$eqHashIndex_1_StorageKey = new $$eqHashIndex_1_StorageKey();

	final HashIndex<$$eqHashIndex_2_StorageKey> $$eqHashIndex_2 = new HashIndex<$$eqHashIndex_2_StorageKey>();

	private final static class $$eqHashIndex_2_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X0;
		private int hashCode;

		public $$eqHashIndex_2_LookupKey_0() {
			// NOP
		}

		public $$eqHashIndex_2_LookupKey_0(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$eqHashIndex_2_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$eqHashIndex_2_LookupKey_0 $$eqHashIndex_2_LookupKey_0 = new $$eqHashIndex_2_LookupKey_0();

	private final static class $$eqHashIndex_2_StorageKey
		extends runtime.DoublyLinkedConstraintList<EqConstraint>
		implements Cloneable<$$eqHashIndex_2_StorageKey> {
		protected compiler.CHRIntermediateForm.arg.argument.IArgument X0;
		private int hashCode;

		public $$eqHashIndex_2_StorageKey() {
			// NOP
		}

		public $$eqHashIndex_2_StorageKey(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.arg.argument.IArgument X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$eqHashIndex_2_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$eqHashIndex_2_StorageKey clone() {
			try {
				return ($$eqHashIndex_2_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$eqHashIndex_2_StorageKey $$eqHashIndex_2_StorageKey = new $$eqHashIndex_2_StorageKey();

	/**
	 * Adds the given {@link EqConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeEq(EqConstraint constraint) {
		$$eqHashIndex_0.putFirstTime(constraint);
		{
			$$eqHashIndex_1_StorageKey list;
			$$eqHashIndex_1_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$eqHashIndex_1.insertOrGet($$eqHashIndex_1_StorageKey)) == null) {
				$$eqHashIndex_1_StorageKey.addFirst(constraint);
				$$eqHashIndex_1_StorageKey = new $$eqHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		{
			$$eqHashIndex_2_StorageKey list;
			$$eqHashIndex_2_StorageKey.init(
				constraint.get$1()
			);
			if ((list = $$eqHashIndex_2.insertOrGet($$eqHashIndex_2_StorageKey)) == null) {
				$$eqHashIndex_2_StorageKey.addFirst(constraint);
				$$eqHashIndex_2_StorageKey = new $$eqHashIndex_2_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
	}

	final EqConstraint lookupEq_0_0(compiler.CHRIntermediateForm.arg.argument.IArgument $0_value,compiler.CHRIntermediateForm.arg.argument.IArgument $1_value) {
		$$eqHashIndex_0_LookupKey_0.init($0_value,$1_value);
		return $$eqHashIndex_0.get($$eqHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<EqConstraint> lookupEq_1_0(compiler.CHRIntermediateForm.arg.argument.IArgument $0_value) {
		$$eqHashIndex_1_LookupKey_0.init($0_value);
		return $$eqHashIndex_1.get($$eqHashIndex_1_LookupKey_0);
	}

	final runtime.ConstraintIterable<EqConstraint> lookupEq_2_0(compiler.CHRIntermediateForm.arg.argument.IArgument $1_value) {
		$$eqHashIndex_2_LookupKey_0.init($1_value);
		return $$eqHashIndex_2.get($$eqHashIndex_2_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>EqConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>EqConstraint</code>s currently
	 * 	in the constraint store.
	 */
	public Iterator<EqConstraint> lookupEq() {
		return $$eqHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link EqConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupEq()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupEq
	 */
	public Iterable<EqConstraint> getEqConstraints(Filter<? super EqConstraint> filter) {
		return new FilteredIterable<EqConstraint>(
			$$eqHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>EqConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupEq</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>EqConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupEq
	 */
	public Collection<EqConstraint> getEqConstraints()
 {
		return new AbstractUnmodifiableCollection<EqConstraint>() {
			@Override
			public int size() {
				return $$eqHashIndex_0.size();
			}

			@Override
			public Iterator<EqConstraint> iterator() {
				return lookupEq();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>EqConstraint</code>.
	 */
	public void reactivateEqConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>EqConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	public void reactivateEqConstraints(util.iterator.Filtered.Filter<? super EqConstraint> filter) {
		// NOP
	}


	/**
	 * Returns an iterator over all <code>AskConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>AskConstraint</code>s currently
	 * 	in the constraint store.
	 */
	public Iterator<AskConstraint> lookupAsk() {
		return EmptyIterator.getInstance();
	}

	/**
	 * Returns an {@link Iterable} over all {@link AskConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupAsk()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupAsk
	 */
	public Iterable<AskConstraint> getAskConstraints(Filter<? super AskConstraint> filter) {
		return Empty.getInstance();
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>AskConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupAsk</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>AskConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupAsk
	 */
	public Collection<AskConstraint> getAskConstraints()
 {
		return Empty.getInstance();
	}

	/**
	 * Reactivates all constraints of type <code>AskConstraint</code>.
	 */
	public void reactivateAskConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>AskConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	public void reactivateAskConstraints(util.iterator.Filtered.Filter<? super AskConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		terminateAll($$eqHashIndex_0.iterator());
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.687+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "eq",
		arity = 2,
		fields = {"$0", "$1"}
	)
	public final class EqConstraint extends Constraint implements Key {
		EqConstraint(compiler.CHRIntermediateForm.arg.argument.IArgument $0, compiler.CHRIntermediateForm.arg.argument.IArgument $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.arg.argument.IArgument $0;
		public compiler.CHRIntermediateForm.arg.argument.IArgument get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.arg.argument.IArgument $1;
		public compiler.CHRIntermediateForm.arg.argument.IArgument get$1() { return this.$1; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeEq(EqConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$transitivity_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$eqHashIndex_0.remove(this);
			}
		}

		public final String getIdentifier() {
			return "eq";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.arg.argument.IArgument.class,
				compiler.CHRIntermediateForm.arg.argument.IArgument.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {"="};
		}

		public final boolean hasInfixIdentifiers() {
			return true;
		}

		public final EqHandler getHandler() {
			return EqHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$transitivity_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation eq_1() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument $143 = this.$1;
			if ($143.equals(X)) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation eq_2() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			EqConstraint eq_3;
			eq_3 = lookupEq_0_0(X, Y);
			if (eq_3 != null) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation eq_4() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			stored = true;
			ID = IDcounter++;
			int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
			storeEq(EqConstraint.this);

			$$continuationStack.push(
				new Eq_5()
			);
			return new EqConstraint(Y, X);
		}

		protected final Continuation eq_5() {
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Z = this.$1;
			runtime.ConstraintIterable<EqConstraint> eq_6_lookup;
			eq_6_lookup = lookupEq_2_0(Y);
			if (eq_6_lookup != null) {
				Iterator<EqConstraint> eq_6_iter;
				eq_6_iter = eq_6_lookup.semiUniversalIterator();
				EqConstraint eq_6;
				while (eq_6_iter.hasNext()) {
					eq_6 = eq_6_iter.next();
					if (this != eq_6) {
						if (!stored || !(eq_6.$$transitivity_history.contains(-this.ID)
							|| !$$transitivity_history.insert(eq_6.ID))) {
							compiler.CHRIntermediateForm.arg.argument.IArgument X = eq_6.$0;
							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeEq(EqConstraint.this);
							}

							$$transitivity_history.add(eq_6.ID);
							if (eq_6_iter.hasNext()) {
								$$continuationStack.push(new Eq_5_1(eq_6_iter));
							} else {
								$$continuationStack.push(new Eq_6());
							}
							return new EqConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation eq_6() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			runtime.ConstraintIterable<EqConstraint> eq_5_lookup;
			eq_5_lookup = lookupEq_1_0(Y);
			if (eq_5_lookup != null) {
				Iterator<EqConstraint> eq_5_iter;
				eq_5_iter = eq_5_lookup.semiUniversalIterator();
				EqConstraint eq_5;
				while (eq_5_iter.hasNext()) {
					eq_5 = eq_5_iter.next();
					if (this != eq_5) {
						if (!stored || !(eq_5.$$transitivity_history.contains(this.ID)
							|| !$$transitivity_history.insert(-eq_5.ID))) {
							compiler.CHRIntermediateForm.arg.argument.IArgument Z = eq_5.$1;
							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeEq(EqConstraint.this);
							}

							$$transitivity_history.add(-eq_5.ID);
							if (eq_5_iter.hasNext()) {
								$$continuationStack.push(new Eq_6_1(eq_5_iter));
							}
							return new EqConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = eq_1()) != null) return continuation;
				if ((continuation = eq_2()) != null) return continuation;
				if ((continuation = eq_4()) != null) return continuation;
				if ((continuation = eq_5()) != null) return continuation;
				if ((continuation = eq_6()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeEq(EqConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Eq_5 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = eq_5()) != null) return continuation;
				if ((continuation = eq_6()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Eq_5()";
			}
		}

		protected final class Eq_5_1 extends Continuation {
			private final Iterator<EqConstraint> eq_6_iter;

			public Eq_5_1(Iterator<EqConstraint> eq_6_iter) {
				this.eq_6_iter = eq_6_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = eq_5_1(eq_6_iter)) != null) return continuation;
				if ((continuation = eq_6()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Eq_5_1")
					.append('(')
					.append("eq_6_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation eq_5_1(Iterator<EqConstraint> eq_6_iter) {
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Z = this.$1;
			EqConstraint eq_6;
			do {
				eq_6 = eq_6_iter.next();
				if (this != eq_6) {
					if (!stored || !(eq_6.$$transitivity_history.contains(-this.ID)
						|| !$$transitivity_history.insert(eq_6.ID))) {
						compiler.CHRIntermediateForm.arg.argument.IArgument X = eq_6.$0;
						$$transitivity_history.add(eq_6.ID);
						if (eq_6_iter.hasNext()) {
							$$continuationStack.undoPop();
						} else {
							$$continuationStack.push(new Eq_6());
						}
						return new EqConstraint(X, Z);
					}
				}
			} while (eq_6_iter.hasNext());
			return null;
		}

		protected final class Eq_6 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = eq_6()) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Eq_6()";
			}
		}

		protected final class Eq_6_1 extends Continuation {
			private final Iterator<EqConstraint> eq_5_iter;

			public Eq_6_1(Iterator<EqConstraint> eq_5_iter) {
				this.eq_5_iter = eq_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = eq_6_1(eq_5_iter)) != null) return continuation;
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Eq_6_1")
					.append('(')
					.append("eq_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation eq_6_1(Iterator<EqConstraint> eq_5_iter) {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			EqConstraint eq_5;
			do {
				eq_5 = eq_5_iter.next();
				if (this != eq_5) {
					if (!stored || !(eq_5.$$transitivity_history.contains(this.ID)
						|| !$$transitivity_history.insert(-eq_5.ID))) {
						compiler.CHRIntermediateForm.arg.argument.IArgument Z = eq_5.$1;
						$$transitivity_history.add(-eq_5.ID);
						if (eq_5_iter.hasNext()) {
							$$continuationStack.undoPop();
						}
						return new EqConstraint(X, Z);
					}
				}
			} while (eq_5_iter.hasNext());
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("eq(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof EqHandler.EqConstraint)
			    && this.equals((EqConstraint)other);
		}

		public boolean equals(EqConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.692+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "ask",
		arity = 3,
		fields = {"$0", "$1", "Result"}
	)
	public final class AskConstraint extends Continuation implements IConstraint {
		AskConstraint(compiler.CHRIntermediateForm.arg.argument.IArgument $0, compiler.CHRIntermediateForm.arg.argument.IArgument $1, runtime.BooleanAnswer Result) {
			this.$0 = $0;
			this.$1 = $1;
			this.Result = Result;
		}

		final compiler.CHRIntermediateForm.arg.argument.IArgument $0;
		public compiler.CHRIntermediateForm.arg.argument.IArgument get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.arg.argument.IArgument $1;
		public compiler.CHRIntermediateForm.arg.argument.IArgument get$1() { return this.$1; }

		final runtime.BooleanAnswer Result;
		public runtime.BooleanAnswer getResult() { return this.Result; }

 // No objects of this class should be accessible...; 
		public final boolean isAlive() { return true; }
		public final boolean isStored() { return false; }
		public final boolean isTerminated() { return true; }

		public final String getIdentifier() {
			return "ask";
		}

		public final int getArity() {
			return 3;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1(),
				getResult()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.arg.argument.IArgument.class,
				compiler.CHRIntermediateForm.arg.argument.IArgument.class,
				runtime.BooleanAnswer.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final EqHandler getHandler() {
			return EqHandler.this;
		}

		protected final Continuation ask_1() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			runtime.BooleanAnswer R = this.Result;
			if (X.equals(Y)) {
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation ask_2() {
			compiler.CHRIntermediateForm.arg.argument.IArgument X = this.$0;
			compiler.CHRIntermediateForm.arg.argument.IArgument Y = this.$1;
			runtime.BooleanAnswer R = this.Result;
			EqConstraint eq_7;
			eq_7 = lookupEq_0_0(X, Y);
			if (eq_7 != null) {
				$solver_0.tellEqual(R, true);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation ask_3() {
			runtime.BooleanAnswer R = this.Result;
			$solver_0.tellEqual(R, false);
			return $$continuationStack.pop();
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = ask_1()) != null) return continuation;
				if ((continuation = ask_2()) != null) return continuation;
				if ((continuation = ask_3()) != null) return continuation;
			}
			return $$continuationStack.pop();
		}


		@Override
		public String toString() {
			return new StringBuilder()
				.append("ask(")
				.append($0)
				.append(", ")
				.append($1)
				.append(", ")
				.append(Result)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof EqHandler.AskConstraint)
			    && this.equals((AskConstraint)other);
		}

		public boolean equals(AskConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1)
			    && $solver_0.askEqual(this.Result, other.Result);
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (37 * (37 * (23) + $0.hashCode()) + $1.hashCode()) + Result.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 96889;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == EqConstraint.class)
			return true;
		if (constraintClass == AskConstraint.class)
			return false;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
