/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package compiler.analysis.removal;

import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import runtime.debug.Tracer;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2008-03-10T10:38:16.855+01:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "tells_reactive",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "tells",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "tells_exported",
		arity = 1
	),
	@JCHR_Constraint(
		identifier = "removes",
		arity = 2
	),
	@JCHR_Constraint(
		identifier = "exported",
		arity = 1
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
class RemovalHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	public RemovalHandler() {
		this(runtime.ConstraintSystem.get(), null);
	}

	public RemovalHandler(runtime.ConstraintSystem $$constraintSystem) {
		this($$constraintSystem, null);
	}

	Tracer tracer;
	
	@Override
	public Tracer getTracer() {
		return tracer;
	}
	
	@Override
	public void setTracer(Tracer tracer) {
		this.tracer = tracer;
	}
	
	@Override
	public boolean canBeTraced() {
		return true;
	}

	public RemovalHandler(Tracer $$tracer) {
		this(runtime.ConstraintSystem.get(), $$tracer);
	}

	public RemovalHandler(runtime.ConstraintSystem $$constraintSystem, Tracer $$tracer) {
		super($$constraintSystem);
		this.tracer = $$tracer;
		$$continuationStack = getContinuationStack();
	}

	@Override
	public String getIdentifier() {
		return "removal";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			Tells_reactiveConstraint.class, 
			TellsConstraint.class, 
			Tells_exportedConstraint.class, 
			RemovesConstraint.class, 
			ExportedConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupTells_reactive()
	 * @see #lookupTells()
	 * @see #lookupTells_exported()
	 * @see #lookupRemoves()
	 * @see #lookupExported()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupTells_reactive(),
			lookupTells(),
			lookupTells_exported(),
			lookupRemoves(),
			lookupExported()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupTells_reactive()
	 * @see #lookupTells()
	 * @see #lookupTells_exported()
	 * @see #lookupRemoves()
	 * @see #lookupExported()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupTells_reactive(),
			lookupTells(),
			lookupTells_exported(),
			lookupRemoves(),
			lookupExported()
		);
	}

	RemovalHandler includePackage() {
		return this;
	}
	protected RemovalHandler includeProtected() {
		return this;
	}
	@Override
	public RemovalHandler getTracerView() {
		return this;
	}

	@JCHR_Tells(
		constraint = "tells_reactive",
		warrantsStackOpimization = true
	)
	final void tellTells_reactive(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new Tells_reactiveConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new Tells_reactiveConstraint($0));
		else
			$$continuationQueue.enqueue(new Tells_reactiveConstraint($0));
	}

	@JCHR_Tells(
		constraint = "tells",
		warrantsStackOpimization = true
	)
	final void tellTells(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new TellsConstraint($0, $1));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new TellsConstraint($0, $1));
		else
			$$continuationQueue.enqueue(new TellsConstraint($0, $1));
	}

	@JCHR_Tells(
		constraint = "tells_exported",
		warrantsStackOpimization = true
	)
	final void tellTells_exported(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new Tells_exportedConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new Tells_exportedConstraint($0));
		else
			$$continuationQueue.enqueue(new Tells_exportedConstraint($0));
	}

	@JCHR_Tells(
		constraint = "removes",
		warrantsStackOpimization = true
	)
	final void tellRemoves(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Remover, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Removee) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new RemovesConstraint(Remover, Removee));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new RemovesConstraint(Remover, Removee));
		else
			$$continuationQueue.enqueue(new RemovesConstraint(Remover, Removee));
	}

	@JCHR_Tells(
		constraint = "exported",
		warrantsStackOpimization = true
	)
	final void tellExported(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new ExportedConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new ExportedConstraint($0));
		else
			$$continuationQueue.enqueue(new ExportedConstraint($0));
	}

	protected final HashIndex<Tells_reactiveConstraint> $$tells_reactiveHashIndex_0 = new HashIndex<Tells_reactiveConstraint>();

	private final class $$tells_reactiveHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tells_reactiveHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tells_reactiveHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((Tells_reactiveConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tells_reactiveHashIndex_0_LookupKey_0 $$tells_reactiveHashIndex_0_LookupKey_0 = new $$tells_reactiveHashIndex_0_LookupKey_0();

	private final runtime.DoublyLinkedConstraintList<Tells_reactiveConstraint> $$tells_reactiveConstraintList = new runtime.DoublyLinkedConstraintList<Tells_reactiveConstraint>();

	/**
	 * Adds the given {@link Tells_reactiveConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells_reactive(Tells_reactiveConstraint constraint) {
		$$tells_reactiveHashIndex_0.putFirstTime(constraint);
		$$tells_reactiveConstraintList.addFirst(constraint);
		if (tracer != null) tracer.stored(constraint);
	}

	final Tells_reactiveConstraint lookupTells_reactive_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tells_reactiveHashIndex_0_LookupKey_0.init($0_value);
		return $$tells_reactiveHashIndex_0.get($$tells_reactiveHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<Tells_reactiveConstraint> lookupTells_reactive_1_0() {
		return $$tells_reactiveConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Tells_reactiveConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Tells_reactiveConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Tells_reactiveConstraint> lookupTells_reactive() {
		return $$tells_reactiveConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Tells_reactiveConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells_reactive()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells_reactive
	 */
	Iterable<Tells_reactiveConstraint> getTells_reactiveConstraints(Filter<? super Tells_reactiveConstraint> filter) {
		return new FilteredIterable<Tells_reactiveConstraint>($$tells_reactiveConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Tells_reactiveConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells_reactive</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Tells_reactiveConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells_reactive
	 */
	Collection<Tells_reactiveConstraint> getTells_reactiveConstraints()
 {
		return new AbstractUnmodifiableCollection<Tells_reactiveConstraint>() {
			@Override
			public int size() {
				return $$tells_reactiveHashIndex_0.size();
			}

			@Override
			public Iterator<Tells_reactiveConstraint> iterator() {
				return lookupTells_reactive();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Tells_reactiveConstraint</code>.
	 */
	void reactivateTells_reactiveConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Tells_reactiveConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTells_reactiveConstraints(util.iterator.Filtered.Filter<? super Tells_reactiveConstraint> filter) {
		// NOP
	}

	final HashIndex<$$tellsHashIndex_0_StorageKey> $$tellsHashIndex_0 = new HashIndex<$$tellsHashIndex_0_StorageKey>();

	private final static class $$tellsHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_0_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_0_LookupKey_0 $$tellsHashIndex_0_LookupKey_0 = new $$tellsHashIndex_0_LookupKey_0();

	private final static class $$tellsHashIndex_0_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_0_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_0_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_0_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_0_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_0_StorageKey clone() {
			try {
				return ($$tellsHashIndex_0_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_0_StorageKey $$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();

	final HashIndex<$$tellsHashIndex_1_StorageKey> $$tellsHashIndex_1 = new HashIndex<$$tellsHashIndex_1_StorageKey>();

	private final static class $$tellsHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$tellsHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_1_LookupKey_0 $$tellsHashIndex_1_LookupKey_0 = new $$tellsHashIndex_1_LookupKey_0();

	private final static class $$tellsHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<TellsConstraint>
		implements Cloneable<$$tellsHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tellsHashIndex_1_StorageKey() {
			// NOP
		}

		public $$tellsHashIndex_1_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$tellsHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$tellsHashIndex_1_StorageKey clone() {
			try {
				return ($$tellsHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$tellsHashIndex_1_StorageKey $$tellsHashIndex_1_StorageKey = new $$tellsHashIndex_1_StorageKey();

	protected final HashIndex<TellsConstraint> $$tellsHashIndex_2 = new HashIndex<TellsConstraint>();

	private final class $$tellsHashIndex_2_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$tellsHashIndex_2_LookupKey_0() {
			// NOP
		}

		public $$tellsHashIndex_2_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((TellsConstraint)other).get$0().equals(this.X0) &&
				((TellsConstraint)other).get$1().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tellsHashIndex_2_LookupKey_0 $$tellsHashIndex_2_LookupKey_0 = new $$tellsHashIndex_2_LookupKey_0();

	/**
	 * Adds the given {@link TellsConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells(TellsConstraint constraint) {
		{
			$$tellsHashIndex_0_StorageKey list;
			$$tellsHashIndex_0_StorageKey.init(
				constraint.get$0()
			);
			if ((list = $$tellsHashIndex_0.insertOrGet($$tellsHashIndex_0_StorageKey)) == null) {
				$$tellsHashIndex_0_StorageKey.addFirst(constraint);
				$$tellsHashIndex_0_StorageKey = new $$tellsHashIndex_0_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		{
			$$tellsHashIndex_1_StorageKey list;
			$$tellsHashIndex_1_StorageKey.init(
				constraint.get$1()
			);
			if ((list = $$tellsHashIndex_1.insertOrGet($$tellsHashIndex_1_StorageKey)) == null) {
				$$tellsHashIndex_1_StorageKey.addFirst(constraint);
				$$tellsHashIndex_1_StorageKey = new $$tellsHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		$$tellsHashIndex_2.putFirstTime(constraint);
		if (tracer != null) tracer.stored(constraint);
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tellsHashIndex_0_LookupKey_0.init($0_value);
		return $$tellsHashIndex_0.get($$tellsHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<TellsConstraint> lookupTells_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_1_LookupKey_0.init($1_value);
		return $$tellsHashIndex_1.get($$tellsHashIndex_1_LookupKey_0);
	}

	final TellsConstraint lookupTells_2_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1_value) {
		$$tellsHashIndex_2_LookupKey_0.init($0_value,$1_value);
		return $$tellsHashIndex_2.get($$tellsHashIndex_2_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>TellsConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>TellsConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<TellsConstraint> lookupTells() {
		return new NestedIterator<TellsConstraint>($$tellsHashIndex_0);
	}

	/**
	 * Returns an {@link Iterable} over all {@link TellsConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells
	 */
	Iterable<TellsConstraint> getTellsConstraints(Filter<? super TellsConstraint> filter) {
		return new FilteredIterable<TellsConstraint>(
			new NestedIterable<TellsConstraint>($$tellsHashIndex_0), filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>TellsConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>TellsConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells
	 */
	Collection<TellsConstraint> getTellsConstraints()
 {
		return new AbstractUnmodifiableCollection<TellsConstraint>() {
			@Override
			public int size() {
				return $$tellsHashIndex_2.size();
			}

			@Override
			public Iterator<TellsConstraint> iterator() {
				return lookupTells();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>.
	 */
	void reactivateTellsConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>TellsConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTellsConstraints(util.iterator.Filtered.Filter<? super TellsConstraint> filter) {
		// NOP
	}

	protected final HashIndex<Tells_exportedConstraint> $$tells_exportedHashIndex_0 = new HashIndex<Tells_exportedConstraint>();

	private final class $$tells_exportedHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$tells_exportedHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$tells_exportedHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((Tells_exportedConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$tells_exportedHashIndex_0_LookupKey_0 $$tells_exportedHashIndex_0_LookupKey_0 = new $$tells_exportedHashIndex_0_LookupKey_0();

	private final runtime.DoublyLinkedConstraintList<Tells_exportedConstraint> $$tells_exportedConstraintList = new runtime.DoublyLinkedConstraintList<Tells_exportedConstraint>();

	/**
	 * Adds the given {@link Tells_exportedConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeTells_exported(Tells_exportedConstraint constraint) {
		$$tells_exportedHashIndex_0.putFirstTime(constraint);
		$$tells_exportedConstraintList.addFirst(constraint);
		if (tracer != null) tracer.stored(constraint);
	}

	final Tells_exportedConstraint lookupTells_exported_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$tells_exportedHashIndex_0_LookupKey_0.init($0_value);
		return $$tells_exportedHashIndex_0.get($$tells_exportedHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<Tells_exportedConstraint> lookupTells_exported_1_0() {
		return $$tells_exportedConstraintList;
	}

	/**
	 * Returns an iterator over all <code>Tells_exportedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>Tells_exportedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<Tells_exportedConstraint> lookupTells_exported() {
		return $$tells_exportedConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link Tells_exportedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupTells_exported()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupTells_exported
	 */
	Iterable<Tells_exportedConstraint> getTells_exportedConstraints(Filter<? super Tells_exportedConstraint> filter) {
		return new FilteredIterable<Tells_exportedConstraint>($$tells_exportedConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>Tells_exportedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupTells_exported</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>Tells_exportedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupTells_exported
	 */
	Collection<Tells_exportedConstraint> getTells_exportedConstraints()
 {
		return new AbstractUnmodifiableCollection<Tells_exportedConstraint>() {
			@Override
			public int size() {
				return $$tells_exportedHashIndex_0.size();
			}

			@Override
			public Iterator<Tells_exportedConstraint> iterator() {
				return lookupTells_exported();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>Tells_exportedConstraint</code>.
	 */
	void reactivateTells_exportedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>Tells_exportedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateTells_exportedConstraints(util.iterator.Filtered.Filter<? super Tells_exportedConstraint> filter) {
		// NOP
	}

	protected final HashIndex<RemovesConstraint> $$removesHashIndex_0 = new HashIndex<RemovesConstraint>();

	private final class $$removesHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1;
		private int hashCode;

		public $$removesHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$removesHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X1) {
			this.X0 = X0;
			this.X1 = X1;
			int hashCode = 37 * (37 * (23) + X0.hashCode()) + X1.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((RemovesConstraint)other).getRemover().equals(this.X0) &&
				((RemovesConstraint)other).getRemovee().equals(this.X1);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$removesHashIndex_0_LookupKey_0 $$removesHashIndex_0_LookupKey_0 = new $$removesHashIndex_0_LookupKey_0();

	final HashIndex<$$removesHashIndex_1_StorageKey> $$removesHashIndex_1 = new HashIndex<$$removesHashIndex_1_StorageKey>();

	private final static class $$removesHashIndex_1_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$removesHashIndex_1_LookupKey_0() {
			// NOP
		}

		public $$removesHashIndex_1_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return (($$removesHashIndex_1_StorageKey)other).X0.equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$removesHashIndex_1_LookupKey_0 $$removesHashIndex_1_LookupKey_0 = new $$removesHashIndex_1_LookupKey_0();

	private final static class $$removesHashIndex_1_StorageKey
		extends runtime.DoublyLinkedConstraintList<RemovesConstraint>
		implements Cloneable<$$removesHashIndex_1_StorageKey> {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$removesHashIndex_1_StorageKey() {
			// NOP
		}

		public $$removesHashIndex_1_StorageKey(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return this.X0.equals((($$removesHashIndex_1_StorageKey)other).X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public $$removesHashIndex_1_StorageKey clone() {
			try {
				return ($$removesHashIndex_1_StorageKey)super.clone();
			} catch (CloneNotSupportedException cnse) {
				throw new InternalError();
			}
		}
	}

	private $$removesHashIndex_1_StorageKey $$removesHashIndex_1_StorageKey = new $$removesHashIndex_1_StorageKey();

	/**
	 * Adds the given {@link RemovesConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeRemoves(RemovesConstraint constraint) {
		$$removesHashIndex_0.putFirstTime(constraint);
		{
			$$removesHashIndex_1_StorageKey list;
			$$removesHashIndex_1_StorageKey.init(
				constraint.getRemover()
			);
			if ((list = $$removesHashIndex_1.insertOrGet($$removesHashIndex_1_StorageKey)) == null) {
				$$removesHashIndex_1_StorageKey.addFirst(constraint);
				$$removesHashIndex_1_StorageKey = new $$removesHashIndex_1_StorageKey();
			} else {   // list != null
				list.addFirst(constraint);
			}
		}
		if (tracer != null) tracer.stored(constraint);
	}

	final RemovesConstraint lookupRemoves_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Remover_value,compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Removee_value) {
		$$removesHashIndex_0_LookupKey_0.init(Remover_value,Removee_value);
		return $$removesHashIndex_0.get($$removesHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<RemovesConstraint> lookupRemoves_1_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Remover_value) {
		$$removesHashIndex_1_LookupKey_0.init(Remover_value);
		return $$removesHashIndex_1.get($$removesHashIndex_1_LookupKey_0);
	}

	/**
	 * Returns an iterator over all <code>RemovesConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>RemovesConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<RemovesConstraint> lookupRemoves() {
		return $$removesHashIndex_0.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link RemovesConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupRemoves()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupRemoves
	 */
	Iterable<RemovesConstraint> getRemovesConstraints(Filter<? super RemovesConstraint> filter) {
		return new FilteredIterable<RemovesConstraint>(
			$$removesHashIndex_0, filter
		);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>RemovesConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupRemoves</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>RemovesConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupRemoves
	 */
	Collection<RemovesConstraint> getRemovesConstraints()
 {
		return new AbstractUnmodifiableCollection<RemovesConstraint>() {
			@Override
			public int size() {
				return $$removesHashIndex_0.size();
			}

			@Override
			public Iterator<RemovesConstraint> iterator() {
				return lookupRemoves();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>RemovesConstraint</code>.
	 */
	void reactivateRemovesConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>RemovesConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateRemovesConstraints(util.iterator.Filtered.Filter<? super RemovesConstraint> filter) {
		// NOP
	}

	protected final HashIndex<ExportedConstraint> $$exportedHashIndex_0 = new HashIndex<ExportedConstraint>();

	private final class $$exportedHashIndex_0_LookupKey_0 implements LookupKey {
		protected compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0;
		private int hashCode;

		public $$exportedHashIndex_0_LookupKey_0() {
			// NOP
		}

		public $$exportedHashIndex_0_LookupKey_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}

		public void init(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X0) {
			this.X0 = X0;
			int hashCode = 37 * (23) + X0.hashCode();
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			this.hashCode = hashCode;
		}


		@Override
		public boolean equals(final Object other) {
			return ((ExportedConstraint)other).get$0().equals(this.X0);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

	}

	private final $$exportedHashIndex_0_LookupKey_0 $$exportedHashIndex_0_LookupKey_0 = new $$exportedHashIndex_0_LookupKey_0();

	private final runtime.DoublyLinkedConstraintList<ExportedConstraint> $$exportedConstraintList = new runtime.DoublyLinkedConstraintList<ExportedConstraint>();

	/**
	 * Adds the given {@link ExportedConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeExported(ExportedConstraint constraint) {
		$$exportedHashIndex_0.putFirstTime(constraint);
		$$exportedConstraintList.addFirst(constraint);
		if (tracer != null) tracer.stored(constraint);
	}

	final ExportedConstraint lookupExported_0_0(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0_value) {
		$$exportedHashIndex_0_LookupKey_0.init($0_value);
		return $$exportedHashIndex_0.get($$exportedHashIndex_0_LookupKey_0);
	}

	final runtime.ConstraintIterable<ExportedConstraint> lookupExported_1_0() {
		return $$exportedConstraintList;
	}

	/**
	 * Returns an iterator over all <code>ExportedConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>ExportedConstraint</code>s currently
	 * 	in the constraint store.
	 */
	Iterator<ExportedConstraint> lookupExported() {
		return $$exportedConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link ExportedConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupExported()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupExported
	 */
	Iterable<ExportedConstraint> getExportedConstraints(Filter<? super ExportedConstraint> filter) {
		return new FilteredIterable<ExportedConstraint>($$exportedConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>ExportedConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupExported</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>ExportedConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupExported
	 */
	Collection<ExportedConstraint> getExportedConstraints()
 {
		return new AbstractUnmodifiableCollection<ExportedConstraint>() {
			@Override
			public int size() {
				return $$exportedHashIndex_0.size();
			}

			@Override
			public Iterator<ExportedConstraint> iterator() {
				return lookupExported();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>ExportedConstraint</code>.
	 */
	void reactivateExportedConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>ExportedConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	void reactivateExportedConstraints(util.iterator.Filtered.Filter<? super ExportedConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		terminateAll($$tells_reactiveConstraintList);
		{
			Iterator<? extends runtime.DoublyLinkedConstraintList<TellsConstraint>> outer = $$tellsHashIndex_0.iterator();
			while (outer.hasNext()) terminateAll(outer.next());
		}
		terminateAll($$tells_exportedConstraintList);
		terminateAll($$removesHashIndex_0.iterator());
		terminateAll($$exportedConstraintList);
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.862+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells_reactive",
		arity = 1,
		fields = {"$0"}
	)
	public final class Tells_reactiveConstraint extends Constraint implements Key {
		Tells_reactiveConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells_reactive(Tells_reactiveConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_12_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tells_reactiveHashIndex_0.remove(this);
				if (tracer != null) tracer.removed(this);
			}
			if (tracer != null) tracer.terminated(this);
		}

		public final String getIdentifier() {
			return "tells_reactive";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RemovalHandler getHandler() {
			return RemovalHandler.this;
		}

		protected runtime.history.TuplePropagationHistory $$$rule_12_history = new runtime.history.TuplePropagationHistory();

		protected final Continuation tells_reactive_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			Tells_reactiveConstraint tells_reactive_2;
			tells_reactive_2 = lookupTells_reactive_0_0(X);
			if (tells_reactive_2 != null) {
				if (tracer != null)
					tracer.fires("$rule_3", 1, tells_reactive_2, this);

				this.terminate();

				if (tracer != null)
					tracer.fired("$rule_3", 1, tells_reactive_2, this);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_reactive_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_2_lookup;
			tells_2_lookup = lookupTells_0_0(X);
			if (tells_2_lookup != null) {
				Iterator<TellsConstraint> tells_2_iter;
				tells_2_iter = tells_2_lookup.semiUniversalIterator();
				TellsConstraint tells_2;
				tells_2_label: while (tells_2_iter.hasNext()) {
					tells_2 = tells_2_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = tells_2.$1;
					if (Y.isReactive()) {
						ExportedConstraint exported_4;
						exported_4 = lookupExported_0_0(Y);
						if (exported_4 != null) {
							if (tracer != null)
								tracer.fires("$rule_4", 0, this, exported_4, tells_2);

							tells_2.terminate();

							if (tracer != null)
								tracer.fired("$rule_4", 0, this, exported_4, tells_2);
							continue tells_2_label;
						}
					}
				}
			}
			return null;
		}

		protected final Continuation tells_reactive_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_6_lookup;
			tells_6_lookup = lookupTells_1_0(Y);
			if (tells_6_lookup != null) {
				Iterator<TellsConstraint> tells_6_iter;
				tells_6_iter = tells_6_lookup.universalIterator();
				TellsConstraint tells_6;
				while (tells_6_iter.hasNext()) {
					tells_6 = tells_6_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_6.$0;
					if (tracer != null)
						tracer.fires("$rule_7", 1, tells_6, this);

					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells_reactive(Tells_reactiveConstraint.this);

					if (tells_6_iter.hasNext()) {
						$$continuationStack.push(new Tells_reactive_4_1(tells_6, tells_6_iter));
					} else {
						$$continuationStack.push(new Tells_reactive_5());
						$$continuationStack.push(new RuleFiredContinuation("$rule_7", 1, false, tells_6, this));
					}
					return new Tells_reactiveConstraint(X);
				}
			}
			return null;
		}

		protected final Continuation tells_reactive_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<ExportedConstraint> exported_6_lookup;
			exported_6_lookup = lookupExported_1_0();
			Iterator<ExportedConstraint> exported_6_iter;
			exported_6_iter = exported_6_lookup.semiUniversalIterator();
			ExportedConstraint exported_6;
			while (exported_6_iter.hasNext()) {
				exported_6 = exported_6_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = exported_6.$0;
				if (Y.isReactive()) {
					runtime.ConstraintIterable<RemovesConstraint> removes_5_lookup;
					removes_5_lookup = lookupRemoves_1_0(Y);
					if (removes_5_lookup != null) {
						Iterator<RemovesConstraint> removes_5_iter;
						removes_5_iter = removes_5_lookup.semiUniversalIterator();
						RemovesConstraint removes_5;
						while (removes_5_iter.hasNext()) {
							removes_5 = removes_5_iter.next();
							runtime.history.Tuple3 $$tuple = null;							if (!stored || !(
								exported_6.$$$rule_12_history.contains($$tuple = new runtime.history.Tuple3(this.ID, exported_6.getConstraintId(), removes_5.getConstraintId()))
								|| removes_5.$$$rule_12_history.contains($$tuple)
								|| !$$$rule_12_history.insert($$tuple)
							)) {
								if (tracer != null)
									tracer.fires("$rule_12", 0, this, exported_6, removes_5);

								if (!stored) {
									stored = true;
									ID = IDcounter++;
									$$$rule_12_history.add(new runtime.history.Tuple3(this.ID, exported_6.getConstraintId(), removes_5.getConstraintId()));
									int hashCode = 37 * (23) + $0.hashCode();
									hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
									hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
									this.hashCode = hashCode;
									storeTells_reactive(Tells_reactiveConstraint.this);
								}

								$$continuationStack.push(
									new RuleFiredContinuation("$rule_12", 0, true, this, exported_6, removes_5),
									new Tells_reactive_5_1(exported_6, removes_5, exported_6_iter, removes_5_iter, Y)
								);
								return new RemovesConstraint(X, Y);
							}
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (tracer != null) tracer.activated(this);

			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_reactive_1()) != null) return continuation;
				if ((continuation = tells_reactive_3()) != null) return continuation;
				if ((continuation = tells_reactive_4()) != null) return continuation;
				if ((continuation = tells_reactive_5()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells_reactive(Tells_reactiveConstraint.this);
				}

				if (tracer != null) tracer.suspended(this);
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_reactive_4_1 extends Continuation {
			private final TellsConstraint tells_6;
			private final Iterator<TellsConstraint> tells_6_iter;

			public Tells_reactive_4_1(TellsConstraint tells_6, Iterator<TellsConstraint> tells_6_iter) {
				this.tells_6 = tells_6;
				this.tells_6_iter = tells_6_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_reactive_4_1(tells_6, tells_6_iter)) != null) return continuation;
				if ((continuation = tells_reactive_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_reactiveConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_reactive_4_1")
					.append('(')
					.append(tells_6)
					.append(", ")
					.append("tells_6_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_reactive_4_1(TellsConstraint tells_6, Iterator<TellsConstraint> tells_6_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			while (tells_6_iter.hasNext()) {
				tells_6 = tells_6_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_6.$0;
				if (tracer != null)
					tracer.fires("$rule_7", 1, tells_6, this);

				if (tells_6_iter.hasNext()) {
					$$continuationStack.undoPop();
				} else {
					$$continuationStack.push(new Tells_reactive_5());
					$$continuationStack.push(new RuleFiredContinuation("$rule_7", 1, false, tells_6, this));
				}
				return new Tells_reactiveConstraint(X);
			}
			return null;
		}

		protected final class Tells_reactive_5 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_reactive_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_reactiveConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_reactive_5()";
			}
		}

		protected final class RuleFiredContinuation extends Continuation {
			private final String ruleId;
			private final int activeIndex;
			private final boolean suspendAfter;
			private final Constraint[] constraints;

			public RuleFiredContinuation(String ruleId, int activeIndex, boolean suspendAfter, Constraint... constraints) {
				this.ruleId = ruleId;
				this.activeIndex = activeIndex;
				this.suspendAfter = suspendAfter;
				this.constraints = constraints;
			}

			@Override
			protected Continuation call() {
				if (tracer != null) {
					tracer.fired(ruleId, activeIndex, constraints);
					if (suspendAfter) tracer.suspended(constraints[activeIndex]);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "RuleFiredContinuation(" + ruleId + ", ...)";
			}
		}

		protected final class Tells_reactive_5_1 extends Continuation {
			private final ExportedConstraint exported_6;
			private final RemovesConstraint removes_5;
			private final Iterator<ExportedConstraint> exported_6_iter;
			private final Iterator<RemovesConstraint> removes_5_iter;
			private final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y;

			public Tells_reactive_5_1(ExportedConstraint exported_6, RemovesConstraint removes_5, Iterator<ExportedConstraint> exported_6_iter, Iterator<RemovesConstraint> removes_5_iter, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y) {
				this.exported_6 = exported_6;
				this.removes_5 = removes_5;
				this.exported_6_iter = exported_6_iter;
				this.removes_5_iter = removes_5_iter;
				this.Y = Y;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_reactive_5_1(exported_6, removes_5, exported_6_iter, removes_5_iter, Y)) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_reactiveConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_reactive_5_1")
					.append('(')
					.append(exported_6)
					.append(", ")
					.append(removes_5)
					.append(", ")
					.append("exported_6_iter")
					.append(", ")
					.append("removes_5_iter")
					.append(", ")
					.append(Y)
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_reactive_5_1(ExportedConstraint exported_6, RemovesConstraint removes_5, Iterator<ExportedConstraint> exported_6_iter, Iterator<RemovesConstraint> removes_5_iter, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			while (first || exported_6_iter.hasNext()) {
				if (!first) exported_6 = exported_6_iter.next();
				if (!first) Y = exported_6.$0;
				if (first || Y.isReactive()) {
					runtime.ConstraintIterable<RemovesConstraint> removes_5_lookup;
					removes_5_lookup = first? null : lookupRemoves_1_0(Y);
					if (first || removes_5_lookup != null) {
						if (!first) removes_5_iter = removes_5_lookup.semiUniversalIterator();
						first = false;
						while (removes_5_iter.hasNext()) {
							removes_5 = removes_5_iter.next();
							runtime.history.Tuple3 $$tuple = null;							if (!stored || !(
								exported_6.$$$rule_12_history.contains($$tuple = new runtime.history.Tuple3(this.ID, exported_6.getConstraintId(), removes_5.getConstraintId()))
								|| removes_5.$$$rule_12_history.contains($$tuple)
								|| !$$$rule_12_history.insert($$tuple)
							)) {
								if (tracer != null)
									tracer.fires("$rule_12", 0, this, exported_6, removes_5);

								$$continuationStack.push(
									new RuleFiredContinuation("$rule_12", 0, true, this, exported_6, removes_5),
									new Tells_reactive_5_1(exported_6, removes_5, exported_6_iter, removes_5_iter, Y)
								);
								return new RemovesConstraint(X, Y);
							}
						}
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells_reactive(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RemovalHandler.Tells_reactiveConstraint)
			    && this.equals((Tells_reactiveConstraint)other);
		}

		public boolean equals(Tells_reactiveConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.867+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells",
		arity = 2,
		fields = {"$0", "$1"}
	)
	public final class TellsConstraint extends Constraint implements Key {
		TellsConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1) {
			this.$0 = $0;
			this.$1 = $1;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $1;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$1() { return this.$1; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells(TellsConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_8_history = null;
				$$$rule_10_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tellsHashIndex_2.remove(this);
				if (tracer != null) tracer.removed(this);
			}
			if (tracer != null) tracer.terminated(this);
		}

		public final String getIdentifier() {
			return "tells";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0(),
				get$1()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RemovalHandler getHandler() {
			return RemovalHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$$rule_8_history = new runtime.history.IdentifierPropagationHistory();

		protected runtime.history.IdentifierPropagationHistory $$$rule_10_history = new runtime.history.IdentifierPropagationHistory();

		protected final Continuation tells_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			Tells_exportedConstraint tells_exported_3;
			tells_exported_3 = lookupTells_exported_0_0(X);
			if (tells_exported_3 != null) {
				ExportedConstraint exported_3;
				exported_3 = lookupExported_0_0(Y);
				if (exported_3 != null) {
					if (tracer != null)
						tracer.fires("$rule_2", 2, tells_exported_3, exported_3, this);

					this.terminate();

					if (tracer != null)
						tracer.fired("$rule_2", 2, tells_exported_3, exported_3, this);
					return $$continuationStack.pop();
				}
			}
			return null;
		}

		protected final Continuation tells_2() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			if (Y.isReactive()) {
				Tells_reactiveConstraint tells_reactive_3;
				tells_reactive_3 = lookupTells_reactive_0_0(X);
				if (tells_reactive_3 != null) {
					ExportedConstraint exported_4;
					exported_4 = lookupExported_0_0(Y);
					if (exported_4 != null) {
						if (tracer != null)
							tracer.fires("$rule_4", 2, tells_reactive_3, exported_4, this);

						this.terminate();

						if (tracer != null)
							tracer.fired("$rule_4", 2, tells_reactive_3, exported_4, this);
						return $$continuationStack.pop();
					}
				}
			}
			return null;
		}

		protected final Continuation tells_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			TellsConstraint tells_4;
			tells_4 = lookupTells_2_0(X, Y);
			if (tells_4 != null) {
				if (tracer != null)
					tracer.fires("$rule_5", 1, tells_4, this);

				this.terminate();

				if (tracer != null)
					tracer.fired("$rule_5", 1, tells_4, this);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			Tells_exportedConstraint tells_exported_4;
			tells_exported_4 = lookupTells_exported_0_0(Y);
			if (tells_exported_4 != null) {
				if (tracer != null)
					tracer.fires("$rule_6", 0, this, tells_exported_4);

				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells(TellsConstraint.this);

				$$continuationStack.push(
					new RuleFiredContinuation("$rule_6", 0, false, this, tells_exported_4),
					new Tells_6()
				);
				return new Tells_exportedConstraint(X);
			}
			return null;
		}

		protected final Continuation tells_6() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			Tells_reactiveConstraint tells_reactive_4;
			tells_reactive_4 = lookupTells_reactive_0_0(Y);
			if (tells_reactive_4 != null) {
				if (tracer != null)
					tracer.fires("$rule_7", 0, this, tells_reactive_4);

				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells(TellsConstraint.this);
				}

				$$continuationStack.push(
					new RuleFiredContinuation("$rule_7", 0, false, this, tells_reactive_4),
					new Tells_7()
				);
				return new Tells_reactiveConstraint(X);
			}
			return null;
		}

		protected final Continuation tells_7() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_8_lookup;
			tells_8_lookup = lookupTells_1_0(Y);
			if (tells_8_lookup != null) {
				Iterator<TellsConstraint> tells_8_iter;
				tells_8_iter = tells_8_lookup.universalIterator();
				TellsConstraint tells_8;
				while (tells_8_iter.hasNext()) {
					tells_8 = tells_8_iter.next();
					if (this != tells_8) {
						if (!stored || !(tells_8.$$$rule_8_history.contains(-this.ID)
							|| !$$$rule_8_history.insert(tells_8.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_8.$0;
							if (tracer != null)
								tracer.fires("$rule_8", 1, tells_8, this);

							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeTells(TellsConstraint.this);
							}

							$$$rule_8_history.add(tells_8.ID);
							if (tells_8_iter.hasNext()) {
								$$continuationStack.push(new Tells_7_1(tells_8, tells_8_iter));
							} else {
								$$continuationStack.push(new Tells_8());
								$$continuationStack.push(new RuleFiredContinuation("$rule_8", 1, false, tells_8, this));
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation tells_8() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.ConstraintIterable<TellsConstraint> tells_7_lookup;
			tells_7_lookup = lookupTells_0_0(Y);
			if (tells_7_lookup != null) {
				Iterator<TellsConstraint> tells_7_iter;
				tells_7_iter = tells_7_lookup.universalIterator();
				TellsConstraint tells_7;
				while (tells_7_iter.hasNext()) {
					tells_7 = tells_7_iter.next();
					if (this != tells_7) {
						if (!stored || !(tells_7.$$$rule_8_history.contains(this.ID)
							|| !$$$rule_8_history.insert(-tells_7.ID))) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_7.$1;
							if (tracer != null)
								tracer.fires("$rule_8", 0, this, tells_7);

							if (!stored) {
								stored = true;
								ID = IDcounter++;
								int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeTells(TellsConstraint.this);
							}

							$$$rule_8_history.add(-tells_7.ID);
							if (tells_7_iter.hasNext()) {
								$$continuationStack.push(new Tells_8_1(tells_7, tells_7_iter));
							} else {
								$$continuationStack.push(new Tells_9());
								$$continuationStack.push(new RuleFiredContinuation("$rule_8", 0, false, this, tells_7));
							}
							return new TellsConstraint(X, Z);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation tells_9() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			runtime.ConstraintIterable<RemovesConstraint> removes_3_lookup;
			removes_3_lookup = lookupRemoves_1_0(Y);
			if (removes_3_lookup != null) {
				Iterator<RemovesConstraint> removes_3_iter;
				removes_3_iter = removes_3_lookup.semiUniversalIterator();
				RemovesConstraint removes_3;
				while (removes_3_iter.hasNext()) {
					removes_3 = removes_3_iter.next();
					if (!stored || !(removes_3.$$$rule_10_history.contains(this.ID)
						|| !$$$rule_10_history.insert(removes_3.getConstraintId()))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = removes_3.Removee;
						if (tracer != null)
							tracer.fires("$rule_10", 0, this, removes_3);

						if (!stored) {
							stored = true;
							ID = IDcounter++;
							int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
							hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
							hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
							this.hashCode = hashCode;
							storeTells(TellsConstraint.this);
						}

						$$$rule_10_history.add(removes_3.getConstraintId());
						if (removes_3_iter.hasNext()) {
							$$continuationStack.push(new Tells_9_1(removes_3, removes_3_iter));
						}
						$$continuationStack.push(
							new RuleFiredContinuation("$rule_10", 0, true, this, removes_3)
						);
						return new RemovesConstraint(X, Z);
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (tracer != null) tracer.activated(this);

			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_1()) != null) return continuation;
				if ((continuation = tells_2()) != null) return continuation;
				if ((continuation = tells_3()) != null) return continuation;
				if ((continuation = tells_5()) != null) return continuation;
				if ((continuation = tells_6()) != null) return continuation;
				if ((continuation = tells_7()) != null) return continuation;
				if ((continuation = tells_8()) != null) return continuation;
				if ((continuation = tells_9()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells(TellsConstraint.this);
				}

				if (tracer != null) tracer.suspended(this);
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_6 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_6()) != null) return continuation;
					if ((continuation = tells_7()) != null) return continuation;
					if ((continuation = tells_8()) != null) return continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_6()";
			}
		}

		protected final class RuleFiredContinuation extends Continuation {
			private final String ruleId;
			private final int activeIndex;
			private final boolean suspendAfter;
			private final Constraint[] constraints;

			public RuleFiredContinuation(String ruleId, int activeIndex, boolean suspendAfter, Constraint... constraints) {
				this.ruleId = ruleId;
				this.activeIndex = activeIndex;
				this.suspendAfter = suspendAfter;
				this.constraints = constraints;
			}

			@Override
			protected Continuation call() {
				if (tracer != null) {
					tracer.fired(ruleId, activeIndex, constraints);
					if (suspendAfter) tracer.suspended(constraints[activeIndex]);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "RuleFiredContinuation(" + ruleId + ", ...)";
			}
		}

		protected final class Tells_7 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_7()) != null) return continuation;
					if ((continuation = tells_8()) != null) return continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_7()";
			}
		}

		protected final class Tells_7_1 extends Continuation {
			private final TellsConstraint tells_8;
			private final Iterator<TellsConstraint> tells_8_iter;

			public Tells_7_1(TellsConstraint tells_8, Iterator<TellsConstraint> tells_8_iter) {
				this.tells_8 = tells_8;
				this.tells_8_iter = tells_8_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_7_1(tells_8, tells_8_iter)) != null) return continuation;
					if ((continuation = tells_8()) != null) return continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_7_1")
					.append('(')
					.append(tells_8)
					.append(", ")
					.append("tells_8_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_7_1(TellsConstraint tells_8, Iterator<TellsConstraint> tells_8_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.$1;
			while (tells_8_iter.hasNext()) {
				tells_8 = tells_8_iter.next();
				if (this != tells_8) {
					if (!stored || !(tells_8.$$$rule_8_history.contains(-this.ID)
						|| !$$$rule_8_history.insert(tells_8.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_8.$0;
						if (tracer != null)
							tracer.fires("$rule_8", 1, tells_8, this);

						$$$rule_8_history.add(tells_8.ID);
						if (tells_8_iter.hasNext()) {
							$$continuationStack.undoPop();
						} else {
							$$continuationStack.push(new Tells_8());
							$$continuationStack.push(new RuleFiredContinuation("$rule_8", 1, false, tells_8, this));
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		protected final class Tells_8 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_8()) != null) return continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_8()";
			}
		}

		protected final class Tells_8_1 extends Continuation {
			private final TellsConstraint tells_7;
			private final Iterator<TellsConstraint> tells_7_iter;

			public Tells_8_1(TellsConstraint tells_7, Iterator<TellsConstraint> tells_7_iter) {
				this.tells_7 = tells_7;
				this.tells_7_iter = tells_7_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_8_1(tells_7, tells_7_iter)) != null) return continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_8_1")
					.append('(')
					.append(tells_7)
					.append(", ")
					.append("tells_7_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_8_1(TellsConstraint tells_7, Iterator<TellsConstraint> tells_7_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			while (tells_7_iter.hasNext()) {
				tells_7 = tells_7_iter.next();
				if (this != tells_7) {
					if (!stored || !(tells_7.$$$rule_8_history.contains(this.ID)
						|| !$$$rule_8_history.insert(-tells_7.ID))) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = tells_7.$1;
						if (tracer != null)
							tracer.fires("$rule_8", 0, this, tells_7);

						$$$rule_8_history.add(-tells_7.ID);
						if (tells_7_iter.hasNext()) {
							$$continuationStack.undoPop();
						} else {
							$$continuationStack.push(new Tells_9());
							$$continuationStack.push(new RuleFiredContinuation("$rule_8", 0, false, this, tells_7));
						}
						return new TellsConstraint(X, Z);
					}
				}
			}
			return null;
		}

		protected final class Tells_9 extends Continuation {
			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = tells_9()) != null) return continuation;
					if (tracer != null) tracer.suspended(TellsConstraint.this);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_9()";
			}
		}

		protected final class Tells_9_1 extends Continuation {
			private final RemovesConstraint removes_3;
			private final Iterator<RemovesConstraint> removes_3_iter;

			public Tells_9_1(RemovesConstraint removes_3, Iterator<RemovesConstraint> removes_3_iter) {
				this.removes_3 = removes_3;
				this.removes_3_iter = removes_3_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_9_1(removes_3, removes_3_iter)) != null) return continuation;
				if (tracer != null) tracer.suspended(TellsConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_9_1")
					.append('(')
					.append(removes_3)
					.append(", ")
					.append("removes_3_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_9_1(RemovesConstraint removes_3, Iterator<RemovesConstraint> removes_3_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$1;
			do {
				removes_3 = removes_3_iter.next();
				if (!stored || !(removes_3.$$$rule_10_history.contains(this.ID)
					|| !$$$rule_10_history.insert(removes_3.getConstraintId()))) {
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = removes_3.Removee;
					if (tracer != null)
						tracer.fires("$rule_10", 0, this, removes_3);

					$$$rule_10_history.add(removes_3.getConstraintId());
					if (removes_3_iter.hasNext()) {
						$$continuationStack.undoPop();
					}
					$$continuationStack.push(
						new RuleFiredContinuation("$rule_10", 0, true, this, removes_3)
					);
					return new RemovesConstraint(X, Z);
				}
			} while (removes_3_iter.hasNext());
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells(")
				.append($0)
				.append(", ")
				.append($1)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RemovalHandler.TellsConstraint)
			    && this.equals((TellsConstraint)other);
		}

		public boolean equals(TellsConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0)
			    && this.$1.equals(other.$1);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + $0.hashCode()) + $1.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.876+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "tells_exported",
		arity = 1,
		fields = {"$0"}
	)
	public final class Tells_exportedConstraint extends Constraint implements Key {
		Tells_exportedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeTells_exported(Tells_exportedConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_11_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$tells_exportedHashIndex_0.remove(this);
				if (tracer != null) tracer.removed(this);
			}
			if (tracer != null) tracer.terminated(this);
		}

		public final String getIdentifier() {
			return "tells_exported";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RemovalHandler getHandler() {
			return RemovalHandler.this;
		}

		protected runtime.history.TuplePropagationHistory $$$rule_11_history = new runtime.history.TuplePropagationHistory();

		protected final Continuation tells_exported_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			Tells_exportedConstraint tells_exported_2;
			tells_exported_2 = lookupTells_exported_0_0(X);
			if (tells_exported_2 != null) {
				if (tracer != null)
					tracer.fires("$rule_1", 1, tells_exported_2, this);

				this.terminate();

				if (tracer != null)
					tracer.fired("$rule_1", 1, tells_exported_2, this);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation tells_exported_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_1_lookup;
			tells_1_lookup = lookupTells_0_0(X);
			if (tells_1_lookup != null) {
				Iterator<TellsConstraint> tells_1_iter;
				tells_1_iter = tells_1_lookup.semiUniversalIterator();
				TellsConstraint tells_1;
				tells_1_label: while (tells_1_iter.hasNext()) {
					tells_1 = tells_1_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = tells_1.$1;
					ExportedConstraint exported_3;
					exported_3 = lookupExported_0_0(Y);
					if (exported_3 != null) {
						if (tracer != null)
							tracer.fires("$rule_2", 0, this, exported_3, tells_1);

						tells_1.terminate();

						if (tracer != null)
							tracer.fired("$rule_2", 0, this, exported_3, tells_1);
						continue tells_1_label;
					}
				}
			}
			return null;
		}

		protected final Continuation tells_exported_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_5_lookup;
			tells_5_lookup = lookupTells_1_0(Y);
			if (tells_5_lookup != null) {
				Iterator<TellsConstraint> tells_5_iter;
				tells_5_iter = tells_5_lookup.universalIterator();
				TellsConstraint tells_5;
				while (tells_5_iter.hasNext()) {
					tells_5 = tells_5_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_5.$0;
					if (tracer != null)
						tracer.fires("$rule_6", 1, tells_5, this);

					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells_exported(Tells_exportedConstraint.this);

					if (tells_5_iter.hasNext()) {
						$$continuationStack.push(new Tells_exported_4_1(tells_5, tells_5_iter));
					} else {
						$$continuationStack.push(new Tells_exported_5());
						$$continuationStack.push(new RuleFiredContinuation("$rule_6", 1, false, tells_5, this));
					}
					return new Tells_exportedConstraint(X);
				}
			}
			return null;
		}

		protected final Continuation tells_exported_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			runtime.ConstraintIterable<ExportedConstraint> exported_5_lookup;
			exported_5_lookup = lookupExported_1_0();
			Iterator<ExportedConstraint> exported_5_iter;
			exported_5_iter = exported_5_lookup.semiUniversalIterator();
			ExportedConstraint exported_5;
			while (exported_5_iter.hasNext()) {
				exported_5 = exported_5_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = exported_5.$0;
				runtime.ConstraintIterable<RemovesConstraint> removes_4_lookup;
				removes_4_lookup = lookupRemoves_1_0(Y);
				if (removes_4_lookup != null) {
					Iterator<RemovesConstraint> removes_4_iter;
					removes_4_iter = removes_4_lookup.semiUniversalIterator();
					RemovesConstraint removes_4;
					while (removes_4_iter.hasNext()) {
						removes_4 = removes_4_iter.next();
						runtime.history.Tuple3 $$tuple = null;						if (!stored || !(
							exported_5.$$$rule_11_history.contains($$tuple = new runtime.history.Tuple3(this.ID, exported_5.getConstraintId(), removes_4.getConstraintId()))
							|| removes_4.$$$rule_11_history.contains($$tuple)
							|| !$$$rule_11_history.insert($$tuple)
						)) {
							if (tracer != null)
								tracer.fires("$rule_11", 0, this, exported_5, removes_4);

							if (!stored) {
								stored = true;
								ID = IDcounter++;
								$$$rule_11_history.add(new runtime.history.Tuple3(this.ID, exported_5.getConstraintId(), removes_4.getConstraintId()));
								int hashCode = 37 * (23) + $0.hashCode();
								hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
								hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
								this.hashCode = hashCode;
								storeTells_exported(Tells_exportedConstraint.this);
							}

							$$continuationStack.push(
								new RuleFiredContinuation("$rule_11", 0, true, this, exported_5, removes_4),
								new Tells_exported_5_1(exported_5, removes_4, exported_5_iter, removes_4_iter, Y)
							);
							return new RemovesConstraint(X, Y);
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (tracer != null) tracer.activated(this);

			if (isAlive()) {
				Continuation continuation;
				if ((continuation = tells_exported_1()) != null) return continuation;
				if ((continuation = tells_exported_3()) != null) return continuation;
				if ((continuation = tells_exported_4()) != null) return continuation;
				if ((continuation = tells_exported_5()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeTells_exported(Tells_exportedConstraint.this);
				}

				if (tracer != null) tracer.suspended(this);
			}
			return $$continuationStack.pop();
		}


		protected final class Tells_exported_4_1 extends Continuation {
			private final TellsConstraint tells_5;
			private final Iterator<TellsConstraint> tells_5_iter;

			public Tells_exported_4_1(TellsConstraint tells_5, Iterator<TellsConstraint> tells_5_iter) {
				this.tells_5 = tells_5;
				this.tells_5_iter = tells_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_exported_4_1(tells_5, tells_5_iter)) != null) return continuation;
				if ((continuation = tells_exported_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_exportedConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_exported_4_1")
					.append('(')
					.append(tells_5)
					.append(", ")
					.append("tells_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_exported_4_1(TellsConstraint tells_5, Iterator<TellsConstraint> tells_5_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			while (tells_5_iter.hasNext()) {
				tells_5 = tells_5_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_5.$0;
				if (tracer != null)
					tracer.fires("$rule_6", 1, tells_5, this);

				if (tells_5_iter.hasNext()) {
					$$continuationStack.undoPop();
				} else {
					$$continuationStack.push(new Tells_exported_5());
					$$continuationStack.push(new RuleFiredContinuation("$rule_6", 1, false, tells_5, this));
				}
				return new Tells_exportedConstraint(X);
			}
			return null;
		}

		protected final class Tells_exported_5 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_exported_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_exportedConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Tells_exported_5()";
			}
		}

		protected final class RuleFiredContinuation extends Continuation {
			private final String ruleId;
			private final int activeIndex;
			private final boolean suspendAfter;
			private final Constraint[] constraints;

			public RuleFiredContinuation(String ruleId, int activeIndex, boolean suspendAfter, Constraint... constraints) {
				this.ruleId = ruleId;
				this.activeIndex = activeIndex;
				this.suspendAfter = suspendAfter;
				this.constraints = constraints;
			}

			@Override
			protected Continuation call() {
				if (tracer != null) {
					tracer.fired(ruleId, activeIndex, constraints);
					if (suspendAfter) tracer.suspended(constraints[activeIndex]);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "RuleFiredContinuation(" + ruleId + ", ...)";
			}
		}

		protected final class Tells_exported_5_1 extends Continuation {
			private final ExportedConstraint exported_5;
			private final RemovesConstraint removes_4;
			private final Iterator<ExportedConstraint> exported_5_iter;
			private final Iterator<RemovesConstraint> removes_4_iter;
			private final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y;

			public Tells_exported_5_1(ExportedConstraint exported_5, RemovesConstraint removes_4, Iterator<ExportedConstraint> exported_5_iter, Iterator<RemovesConstraint> removes_4_iter, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y) {
				this.exported_5 = exported_5;
				this.removes_4 = removes_4;
				this.exported_5_iter = exported_5_iter;
				this.removes_4_iter = removes_4_iter;
				this.Y = Y;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = tells_exported_5_1(exported_5, removes_4, exported_5_iter, removes_4_iter, Y)) != null) return continuation;
				if (tracer != null) tracer.suspended(Tells_exportedConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Tells_exported_5_1")
					.append('(')
					.append(exported_5)
					.append(", ")
					.append(removes_4)
					.append(", ")
					.append("exported_5_iter")
					.append(", ")
					.append("removes_4_iter")
					.append(", ")
					.append(Y)
					.append(')')
					.toString();
			}
		}

		protected final Continuation tells_exported_5_1(ExportedConstraint exported_5, RemovesConstraint removes_4, Iterator<ExportedConstraint> exported_5_iter, Iterator<RemovesConstraint> removes_4_iter, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			while (first || exported_5_iter.hasNext()) {
				if (!first) exported_5 = exported_5_iter.next();
				if (!first) Y = exported_5.$0;
				runtime.ConstraintIterable<RemovesConstraint> removes_4_lookup;
				removes_4_lookup = first? null : lookupRemoves_1_0(Y);
				if (first || removes_4_lookup != null) {
					if (!first) removes_4_iter = removes_4_lookup.semiUniversalIterator();
					first = false;
					while (removes_4_iter.hasNext()) {
						removes_4 = removes_4_iter.next();
						runtime.history.Tuple3 $$tuple = null;						if (!stored || !(
							exported_5.$$$rule_11_history.contains($$tuple = new runtime.history.Tuple3(this.ID, exported_5.getConstraintId(), removes_4.getConstraintId()))
							|| removes_4.$$$rule_11_history.contains($$tuple)
							|| !$$$rule_11_history.insert($$tuple)
						)) {
							if (tracer != null)
								tracer.fires("$rule_11", 0, this, exported_5, removes_4);

							$$continuationStack.push(
								new RuleFiredContinuation("$rule_11", 0, true, this, exported_5, removes_4),
								new Tells_exported_5_1(exported_5, removes_4, exported_5_iter, removes_4_iter, Y)
							);
							return new RemovesConstraint(X, Y);
						}
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("tells_exported(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RemovalHandler.Tells_exportedConstraint)
			    && this.equals((Tells_exportedConstraint)other);
		}

		public boolean equals(Tells_exportedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.881+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "removes",
		arity = 2,
		fields = {"Remover", "Removee"}
	)
	public final class RemovesConstraint extends Constraint implements Key {
		RemovesConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Remover, compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Removee) {
			this.Remover = Remover;
			this.Removee = Removee;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Remover;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint getRemover() { return this.Remover; }

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Removee;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint getRemovee() { return this.Removee; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeRemoves(RemovesConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_10_history = null;
				$$$rule_11_history = null;
				$$$rule_12_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$removesHashIndex_0.remove(this);
				if (tracer != null) tracer.removed(this);
			}
			if (tracer != null) tracer.terminated(this);
		}

		public final String getIdentifier() {
			return "removes";
		}

		public final int getArity() {
			return 2;
		}

		public final Object[] getArguments() {
			return new Object[] {
				getRemover(),
				getRemovee()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class,
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RemovalHandler getHandler() {
			return RemovalHandler.this;
		}

		protected runtime.history.IdentifierPropagationHistory $$$rule_10_history = new runtime.history.IdentifierPropagationHistory();

		protected runtime.history.TuplePropagationHistory $$$rule_11_history = new runtime.history.TuplePropagationHistory();

		protected runtime.history.TuplePropagationHistory $$$rule_12_history = new runtime.history.TuplePropagationHistory();

		protected final Continuation removes_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.Remover;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Removee;
			RemovesConstraint removes_2;
			removes_2 = lookupRemoves_0_0(X, Y);
			if (removes_2 != null) {
				if (tracer != null)
					tracer.fires("$rule_9", 1, removes_2, this);

				this.terminate();

				if (tracer != null)
					tracer.fired("$rule_9", 1, removes_2, this);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation removes_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.Removee;
			runtime.ConstraintIterable<TellsConstraint> tells_9_lookup;
			tells_9_lookup = lookupTells_1_0(Y);
			if (tells_9_lookup != null) {
				Iterator<TellsConstraint> tells_9_iter;
				tells_9_iter = tells_9_lookup.semiUniversalIterator();
				TellsConstraint tells_9;
				while (tells_9_iter.hasNext()) {
					tells_9 = tells_9_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_9.$0;
					if (tracer != null)
						tracer.fires("$rule_10", 1, tells_9, this);

					stored = true;
					ID = IDcounter++;
					$$$rule_10_history.add(tells_9.getConstraintId());
					int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeRemoves(RemovesConstraint.this);

					if (tells_9_iter.hasNext()) {
						$$continuationStack.push(new Removes_3_1(tells_9, tells_9_iter));
					} else {
						$$continuationStack.push(new Removes_4());
						$$continuationStack.push(new RuleFiredContinuation("$rule_10", 1, false, tells_9, this));
					}
					return new RemovesConstraint(X, Z);
				}
			}
			return null;
		}

		protected final Continuation removes_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			ExportedConstraint exported_5;
			exported_5 = lookupExported_0_0(Y);
			if (exported_5 != null) {
				runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_5_lookup;
				tells_exported_5_lookup = lookupTells_exported_1_0();
				Iterator<Tells_exportedConstraint> tells_exported_5_iter;
				tells_exported_5_iter = tells_exported_5_lookup.semiUniversalIterator();
				Tells_exportedConstraint tells_exported_5;
				while (tells_exported_5_iter.hasNext()) {
					tells_exported_5 = tells_exported_5_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_5.$0;
					if (tracer != null)
						tracer.fires("$rule_11", 2, tells_exported_5, exported_5, this);

					if (!stored) {
						stored = true;
						ID = IDcounter++;
						$$$rule_11_history.add(new runtime.history.Tuple3(tells_exported_5.getConstraintId(), exported_5.getConstraintId(), this.ID));
						int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
						hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
						hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
						this.hashCode = hashCode;
						storeRemoves(RemovesConstraint.this);
					}

					$$$rule_11_history.add(new runtime.history.Tuple3(tells_exported_5.getConstraintId(), exported_5.getConstraintId(), this.ID));
					if (tells_exported_5_iter.hasNext()) {
						$$continuationStack.push(new Removes_4_1(tells_exported_5, exported_5, tells_exported_5_iter));
					} else {
						$$continuationStack.push(new Removes_5());
						$$continuationStack.push(new RuleFiredContinuation("$rule_11", 2, false, tells_exported_5, exported_5, this));
					}
					return new RemovesConstraint(X, Y);
				}
			}
			return null;
		}

		protected final Continuation removes_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			if (Y.isReactive()) {
				ExportedConstraint exported_6;
				exported_6 = lookupExported_0_0(Y);
				if (exported_6 != null) {
					runtime.ConstraintIterable<Tells_reactiveConstraint> tells_reactive_5_lookup;
					tells_reactive_5_lookup = lookupTells_reactive_1_0();
					Iterator<Tells_reactiveConstraint> tells_reactive_5_iter;
					tells_reactive_5_iter = tells_reactive_5_lookup.semiUniversalIterator();
					Tells_reactiveConstraint tells_reactive_5;
					while (tells_reactive_5_iter.hasNext()) {
						tells_reactive_5 = tells_reactive_5_iter.next();
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_reactive_5.$0;
						if (tracer != null)
							tracer.fires("$rule_12", 2, tells_reactive_5, exported_6, this);

						if (!stored) {
							stored = true;
							ID = IDcounter++;
							$$$rule_12_history.add(new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), exported_6.getConstraintId(), this.ID));
							int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
							hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
							hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
							this.hashCode = hashCode;
							storeRemoves(RemovesConstraint.this);
						}

						$$$rule_12_history.add(new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), exported_6.getConstraintId(), this.ID));
						if (tells_reactive_5_iter.hasNext()) {
							$$continuationStack.push(new Removes_5_1(tells_reactive_5, exported_6, tells_reactive_5_iter));
						}
						$$continuationStack.push(
							new RuleFiredContinuation("$rule_12", 2, true, tells_reactive_5, exported_6, this)
						);
						return new RemovesConstraint(X, Y);
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (tracer != null) tracer.activated(this);

			if (isAlive()) {
				Continuation continuation;
				if ((continuation = removes_1()) != null) return continuation;
				if ((continuation = removes_3()) != null) return continuation;
				if ((continuation = removes_4()) != null) return continuation;
				if ((continuation = removes_5()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeRemoves(RemovesConstraint.this);
				}

				if (tracer != null) tracer.suspended(this);
			}
			return $$continuationStack.pop();
		}


		protected final class Removes_3_1 extends Continuation {
			private final TellsConstraint tells_9;
			private final Iterator<TellsConstraint> tells_9_iter;

			public Removes_3_1(TellsConstraint tells_9, Iterator<TellsConstraint> tells_9_iter) {
				this.tells_9 = tells_9;
				this.tells_9_iter = tells_9_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = removes_3_1(tells_9, tells_9_iter)) != null) return continuation;
				if ((continuation = removes_4()) != null) return continuation;
				if ((continuation = removes_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(RemovesConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Removes_3_1")
					.append('(')
					.append(tells_9)
					.append(", ")
					.append("tells_9_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation removes_3_1(TellsConstraint tells_9, Iterator<TellsConstraint> tells_9_iter) {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Z = this.Removee;
			do {
				tells_9 = tells_9_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_9.$0;
				if (tracer != null)
					tracer.fires("$rule_10", 1, tells_9, this);

				if (tells_9_iter.hasNext()) {
					$$continuationStack.undoPop();
				} else {
					$$continuationStack.push(new Removes_4());
					$$continuationStack.push(new RuleFiredContinuation("$rule_10", 1, false, tells_9, this));
				}
				return new RemovesConstraint(X, Z);
			} while (tells_9_iter.hasNext());
		}

		protected final class Removes_4 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = removes_4()) != null) return continuation;
				if ((continuation = removes_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(RemovesConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Removes_4()";
			}
		}

		protected final class RuleFiredContinuation extends Continuation {
			private final String ruleId;
			private final int activeIndex;
			private final boolean suspendAfter;
			private final Constraint[] constraints;

			public RuleFiredContinuation(String ruleId, int activeIndex, boolean suspendAfter, Constraint... constraints) {
				this.ruleId = ruleId;
				this.activeIndex = activeIndex;
				this.suspendAfter = suspendAfter;
				this.constraints = constraints;
			}

			@Override
			protected Continuation call() {
				if (tracer != null) {
					tracer.fired(ruleId, activeIndex, constraints);
					if (suspendAfter) tracer.suspended(constraints[activeIndex]);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "RuleFiredContinuation(" + ruleId + ", ...)";
			}
		}

		protected final class Removes_4_1 extends Continuation {
			private final Tells_exportedConstraint tells_exported_5;
			private final ExportedConstraint exported_5;
			private final Iterator<Tells_exportedConstraint> tells_exported_5_iter;

			public Removes_4_1(Tells_exportedConstraint tells_exported_5, ExportedConstraint exported_5, Iterator<Tells_exportedConstraint> tells_exported_5_iter) {
				this.tells_exported_5 = tells_exported_5;
				this.exported_5 = exported_5;
				this.tells_exported_5_iter = tells_exported_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = removes_4_1(tells_exported_5, exported_5, tells_exported_5_iter)) != null) return continuation;
				if ((continuation = removes_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(RemovesConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Removes_4_1")
					.append('(')
					.append(tells_exported_5)
					.append(", ")
					.append(exported_5)
					.append(", ")
					.append("tells_exported_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation removes_4_1(Tells_exportedConstraint tells_exported_5, ExportedConstraint exported_5, Iterator<Tells_exportedConstraint> tells_exported_5_iter) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			if (!first) exported_5 = lookupExported_0_0(Y);
						runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_5_lookup;
			tells_exported_5_lookup = first? null : lookupTells_exported_1_0();
			if (!first) tells_exported_5_iter = tells_exported_5_lookup.semiUniversalIterator();
			first = false;
			do {
				tells_exported_5 = tells_exported_5_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_5.$0;
				if (tracer != null)
					tracer.fires("$rule_11", 2, tells_exported_5, exported_5, this);

				$$$rule_11_history.add(new runtime.history.Tuple3(tells_exported_5.getConstraintId(), exported_5.getConstraintId(), this.ID));
				if (tells_exported_5_iter.hasNext()) {
					$$continuationStack.push(new Removes_4_1(tells_exported_5, exported_5, tells_exported_5_iter));
				} else {
					$$continuationStack.push(new Removes_5());
					$$continuationStack.push(new RuleFiredContinuation("$rule_11", 2, false, tells_exported_5, exported_5, this));
				}
				return new RemovesConstraint(X, Y);
			} while (tells_exported_5_iter.hasNext());
		}

		protected final class Removes_5 extends Continuation {
			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = removes_5()) != null) return continuation;
				if (tracer != null) tracer.suspended(RemovesConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "Removes_5()";
			}
		}

		protected final class Removes_5_1 extends Continuation {
			private final Tells_reactiveConstraint tells_reactive_5;
			private final ExportedConstraint exported_6;
			private final Iterator<Tells_reactiveConstraint> tells_reactive_5_iter;

			public Removes_5_1(Tells_reactiveConstraint tells_reactive_5, ExportedConstraint exported_6, Iterator<Tells_reactiveConstraint> tells_reactive_5_iter) {
				this.tells_reactive_5 = tells_reactive_5;
				this.exported_6 = exported_6;
				this.tells_reactive_5_iter = tells_reactive_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = removes_5_1(tells_reactive_5, exported_6, tells_reactive_5_iter)) != null) return continuation;
				if (tracer != null) tracer.suspended(RemovesConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Removes_5_1")
					.append('(')
					.append(tells_reactive_5)
					.append(", ")
					.append(exported_6)
					.append(", ")
					.append("tells_reactive_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation removes_5_1(Tells_reactiveConstraint tells_reactive_5, ExportedConstraint exported_6, Iterator<Tells_reactiveConstraint> tells_reactive_5_iter) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.Remover;
			if (!first) exported_6 = lookupExported_0_0(Y);
						runtime.ConstraintIterable<Tells_reactiveConstraint> tells_reactive_5_lookup;
			tells_reactive_5_lookup = first? null : lookupTells_reactive_1_0();
			if (!first) tells_reactive_5_iter = tells_reactive_5_lookup.semiUniversalIterator();
			first = false;
			do {
				tells_reactive_5 = tells_reactive_5_iter.next();
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_reactive_5.$0;
				if (tracer != null)
					tracer.fires("$rule_12", 2, tells_reactive_5, exported_6, this);

				$$$rule_12_history.add(new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), exported_6.getConstraintId(), this.ID));
				if (tells_reactive_5_iter.hasNext()) {
					$$continuationStack.push(new Removes_5_1(tells_reactive_5, exported_6, tells_reactive_5_iter));
				}
				$$continuationStack.push(
					new RuleFiredContinuation("$rule_12", 2, true, tells_reactive_5, exported_6, this)
				);
				return new RemovesConstraint(X, Y);
			} while (tells_reactive_5_iter.hasNext());
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("removes(")
				.append(Remover)
				.append(", ")
				.append(Removee)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RemovalHandler.RemovesConstraint)
			    && this.equals((RemovesConstraint)other);
		}

		public boolean equals(RemovesConstraint other) {
			if (this == other) return true;
			return this.Remover.equals(other.Remover)
			    && this.Removee.equals(other.Removee);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (37 * (23) + Remover.hashCode()) + Removee.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}
	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2008-03-10T10:38:16.888+01:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "exported",
		arity = 1,
		fields = {"$0"}
	)
	public final class ExportedConstraint extends Constraint implements Key {
		ExportedConstraint(compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0) {
			this.$0 = $0;
		}

		final compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint $0;
		public compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				storeExported(ExportedConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				$$$rule_11_history = null;
				$$$rule_12_history = null;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
				$$exportedHashIndex_0.remove(this);
				if (tracer != null) tracer.removed(this);
			}
			if (tracer != null) tracer.terminated(this);
		}

		public final String getIdentifier() {
			return "exported";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint.class
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final RemovalHandler getHandler() {
			return RemovalHandler.this;
		}

		protected runtime.history.TuplePropagationHistory $$$rule_11_history = new runtime.history.TuplePropagationHistory();

		protected runtime.history.TuplePropagationHistory $$$rule_12_history = new runtime.history.TuplePropagationHistory();

		protected final Continuation exported_1() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = this.$0;
			ExportedConstraint exported_2;
			exported_2 = lookupExported_0_0(X);
			if (exported_2 != null) {
				if (tracer != null)
					tracer.fires("$rule_0", 1, exported_2, this);

				this.terminate();

				if (tracer != null)
					tracer.fired("$rule_0", 1, exported_2, this);
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation exported_3() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<TellsConstraint> tells_1_lookup;
			tells_1_lookup = lookupTells_1_0(Y);
			if (tells_1_lookup != null) {
				Iterator<TellsConstraint> tells_1_iter;
				tells_1_iter = tells_1_lookup.semiUniversalIterator();
				TellsConstraint tells_1;
				tells_1_label: while (tells_1_iter.hasNext()) {
					tells_1 = tells_1_iter.next();
					compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_1.$0;
					Tells_exportedConstraint tells_exported_3;
					tells_exported_3 = lookupTells_exported_0_0(X);
					if (tells_exported_3 != null) {
						if (tracer != null)
							tracer.fires("$rule_2", 1, tells_exported_3, this, tells_1);

						tells_1.terminate();

						if (tracer != null)
							tracer.fired("$rule_2", 1, tells_exported_3, this, tells_1);
						continue tells_1_label;
					}
				}
			}
			return null;
		}

		protected final Continuation exported_4() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			if (Y.isReactive()) {
				runtime.ConstraintIterable<TellsConstraint> tells_2_lookup;
				tells_2_lookup = lookupTells_1_0(Y);
				if (tells_2_lookup != null) {
					Iterator<TellsConstraint> tells_2_iter;
					tells_2_iter = tells_2_lookup.semiUniversalIterator();
					TellsConstraint tells_2;
					tells_2_label: while (tells_2_iter.hasNext()) {
						tells_2 = tells_2_iter.next();
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_2.$0;
						Tells_reactiveConstraint tells_reactive_3;
						tells_reactive_3 = lookupTells_reactive_0_0(X);
						if (tells_reactive_3 != null) {
							if (tracer != null)
								tracer.fires("$rule_4", 1, tells_reactive_3, this, tells_2);

							tells_2.terminate();

							if (tracer != null)
								tracer.fired("$rule_4", 1, tells_reactive_3, this, tells_2);
							continue tells_2_label;
						}
					}
				}
			}
			return null;
		}

		protected final Continuation exported_5() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			runtime.ConstraintIterable<RemovesConstraint> removes_4_lookup;
			removes_4_lookup = lookupRemoves_1_0(Y);
			if (removes_4_lookup != null) {
				Iterator<RemovesConstraint> removes_4_iter;
				removes_4_iter = removes_4_lookup.semiUniversalIterator();
				RemovesConstraint removes_4;
				while (removes_4_iter.hasNext()) {
					removes_4 = removes_4_iter.next();
					runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_5_lookup;
					tells_exported_5_lookup = lookupTells_exported_1_0();
					Iterator<Tells_exportedConstraint> tells_exported_5_iter;
					tells_exported_5_iter = tells_exported_5_lookup.semiUniversalIterator();
					Tells_exportedConstraint tells_exported_5;
					while (tells_exported_5_iter.hasNext()) {
						tells_exported_5 = tells_exported_5_iter.next();
						runtime.history.Tuple3 $$tuple = null;						if (!stored || !(
							tells_exported_5.$$$rule_11_history.contains($$tuple = new runtime.history.Tuple3(tells_exported_5.getConstraintId(), this.ID, removes_4.getConstraintId()))
							|| removes_4.$$$rule_11_history.contains($$tuple)
							|| !$$$rule_11_history.insert($$tuple)
						)) {
							compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_5.$0;
							if (tracer != null)
								tracer.fires("$rule_11", 1, tells_exported_5, this, removes_4);

							stored = true;
							ID = IDcounter++;
							$$$rule_11_history.add(new runtime.history.Tuple3(tells_exported_5.getConstraintId(), this.ID, removes_4.getConstraintId()));
							int hashCode = 37 * (23) + $0.hashCode();
							hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
							hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
							this.hashCode = hashCode;
							storeExported(ExportedConstraint.this);

							$$continuationStack.push(
								new RuleFiredContinuation("$rule_11", 1, false, tells_exported_5, this, removes_4),
								new Exported_5_1(tells_exported_5, removes_4, removes_4_iter, tells_exported_5_iter)
							);
							return new RemovesConstraint(X, Y);
						}
					}
				}
			}
			return null;
		}

		protected final Continuation exported_6() {
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			if (Y.isReactive()) {
				runtime.ConstraintIterable<RemovesConstraint> removes_5_lookup;
				removes_5_lookup = lookupRemoves_1_0(Y);
				if (removes_5_lookup != null) {
					Iterator<RemovesConstraint> removes_5_iter;
					removes_5_iter = removes_5_lookup.semiUniversalIterator();
					RemovesConstraint removes_5;
					while (removes_5_iter.hasNext()) {
						removes_5 = removes_5_iter.next();
						runtime.ConstraintIterable<Tells_reactiveConstraint> tells_reactive_5_lookup;
						tells_reactive_5_lookup = lookupTells_reactive_1_0();
						Iterator<Tells_reactiveConstraint> tells_reactive_5_iter;
						tells_reactive_5_iter = tells_reactive_5_lookup.semiUniversalIterator();
						Tells_reactiveConstraint tells_reactive_5;
						while (tells_reactive_5_iter.hasNext()) {
							tells_reactive_5 = tells_reactive_5_iter.next();
							runtime.history.Tuple3 $$tuple = null;							if (!stored || !(
								tells_reactive_5.$$$rule_12_history.contains($$tuple = new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), this.ID, removes_5.getConstraintId()))
								|| removes_5.$$$rule_12_history.contains($$tuple)
								|| !$$$rule_12_history.insert($$tuple)
							)) {
								compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_reactive_5.$0;
								if (tracer != null)
									tracer.fires("$rule_12", 1, tells_reactive_5, this, removes_5);

								if (!stored) {
									stored = true;
									ID = IDcounter++;
									$$$rule_12_history.add(new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), this.ID, removes_5.getConstraintId()));
									int hashCode = 37 * (23) + $0.hashCode();
									hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
									hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
									this.hashCode = hashCode;
									storeExported(ExportedConstraint.this);
								}

								$$continuationStack.push(
									new RuleFiredContinuation("$rule_12", 1, true, tells_reactive_5, this, removes_5),
									new Exported_6_1(tells_reactive_5, removes_5, removes_5_iter, tells_reactive_5_iter)
								);
								return new RemovesConstraint(X, Y);
							}
						}
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (tracer != null) tracer.activated(this);

			if (isAlive()) {
				Continuation continuation;
				if ((continuation = exported_1()) != null) return continuation;
				if ((continuation = exported_3()) != null) return continuation;
				if ((continuation = exported_4()) != null) return continuation;
				if ((continuation = exported_5()) != null) return continuation;
				if ((continuation = exported_6()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					int hashCode = 37 * (23) + $0.hashCode();
					hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
					hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
					this.hashCode = hashCode;
					storeExported(ExportedConstraint.this);
				}

				if (tracer != null) tracer.suspended(this);
			}
			return $$continuationStack.pop();
		}


		protected final class Exported_5_1 extends Continuation {
			private final Tells_exportedConstraint tells_exported_5;
			private final RemovesConstraint removes_4;
			private final Iterator<RemovesConstraint> removes_4_iter;
			private final Iterator<Tells_exportedConstraint> tells_exported_5_iter;

			public Exported_5_1(Tells_exportedConstraint tells_exported_5, RemovesConstraint removes_4, Iterator<RemovesConstraint> removes_4_iter, Iterator<Tells_exportedConstraint> tells_exported_5_iter) {
				this.tells_exported_5 = tells_exported_5;
				this.removes_4 = removes_4;
				this.removes_4_iter = removes_4_iter;
				this.tells_exported_5_iter = tells_exported_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = exported_5_1(tells_exported_5, removes_4, removes_4_iter, tells_exported_5_iter)) != null) return continuation;
				if ((continuation = exported_6()) != null) return continuation;
				if (tracer != null) tracer.suspended(ExportedConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Exported_5_1")
					.append('(')
					.append(tells_exported_5)
					.append(", ")
					.append(removes_4)
					.append(", ")
					.append("removes_4_iter")
					.append(", ")
					.append("tells_exported_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation exported_5_1(Tells_exportedConstraint tells_exported_5, RemovesConstraint removes_4, Iterator<RemovesConstraint> removes_4_iter, Iterator<Tells_exportedConstraint> tells_exported_5_iter) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			while (first || removes_4_iter.hasNext()) {
				if (!first) removes_4 = removes_4_iter.next();
				runtime.ConstraintIterable<Tells_exportedConstraint> tells_exported_5_lookup;
				tells_exported_5_lookup = first? null : lookupTells_exported_1_0();
				if (!first) tells_exported_5_iter = tells_exported_5_lookup.semiUniversalIterator();
				first = false;
				while (tells_exported_5_iter.hasNext()) {
					tells_exported_5 = tells_exported_5_iter.next();
					runtime.history.Tuple3 $$tuple = null;					if (!stored || !(
						tells_exported_5.$$$rule_11_history.contains($$tuple = new runtime.history.Tuple3(tells_exported_5.getConstraintId(), this.ID, removes_4.getConstraintId()))
						|| removes_4.$$$rule_11_history.contains($$tuple)
						|| !$$$rule_11_history.insert($$tuple)
					)) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_exported_5.$0;
						if (tracer != null)
							tracer.fires("$rule_11", 1, tells_exported_5, this, removes_4);

						$$continuationStack.push(
							new RuleFiredContinuation("$rule_11", 1, false, tells_exported_5, this, removes_4),
							new Exported_5_1(tells_exported_5, removes_4, removes_4_iter, tells_exported_5_iter)
						);
						return new RemovesConstraint(X, Y);
					}
				}
			}
			return null;
		}

		protected final class RuleFiredContinuation extends Continuation {
			private final String ruleId;
			private final int activeIndex;
			private final boolean suspendAfter;
			private final Constraint[] constraints;

			public RuleFiredContinuation(String ruleId, int activeIndex, boolean suspendAfter, Constraint... constraints) {
				this.ruleId = ruleId;
				this.activeIndex = activeIndex;
				this.suspendAfter = suspendAfter;
				this.constraints = constraints;
			}

			@Override
			protected Continuation call() {
				if (tracer != null) {
					tracer.fired(ruleId, activeIndex, constraints);
					if (suspendAfter) tracer.suspended(constraints[activeIndex]);
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return "RuleFiredContinuation(" + ruleId + ", ...)";
			}
		}

		protected final class Exported_6_1 extends Continuation {
			private final Tells_reactiveConstraint tells_reactive_5;
			private final RemovesConstraint removes_5;
			private final Iterator<RemovesConstraint> removes_5_iter;
			private final Iterator<Tells_reactiveConstraint> tells_reactive_5_iter;

			public Exported_6_1(Tells_reactiveConstraint tells_reactive_5, RemovesConstraint removes_5, Iterator<RemovesConstraint> removes_5_iter, Iterator<Tells_reactiveConstraint> tells_reactive_5_iter) {
				this.tells_reactive_5 = tells_reactive_5;
				this.removes_5 = removes_5;
				this.removes_5_iter = removes_5_iter;
				this.tells_reactive_5_iter = tells_reactive_5_iter;
			}

			@Override
			protected Continuation call() {
				Continuation continuation;
				if ((continuation = exported_6_1(tells_reactive_5, removes_5, removes_5_iter, tells_reactive_5_iter)) != null) return continuation;
				if (tracer != null) tracer.suspended(ExportedConstraint.this);
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Exported_6_1")
					.append('(')
					.append(tells_reactive_5)
					.append(", ")
					.append(removes_5)
					.append(", ")
					.append("removes_5_iter")
					.append(", ")
					.append("tells_reactive_5_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation exported_6_1(Tells_reactiveConstraint tells_reactive_5, RemovesConstraint removes_5, Iterator<RemovesConstraint> removes_5_iter, Iterator<Tells_reactiveConstraint> tells_reactive_5_iter) {
			boolean first = true;
			compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint Y = this.$0;
			while (first || removes_5_iter.hasNext()) {
				if (!first) removes_5 = removes_5_iter.next();
				runtime.ConstraintIterable<Tells_reactiveConstraint> tells_reactive_5_lookup;
				tells_reactive_5_lookup = first? null : lookupTells_reactive_1_0();
				if (!first) tells_reactive_5_iter = tells_reactive_5_lookup.semiUniversalIterator();
				first = false;
				while (tells_reactive_5_iter.hasNext()) {
					tells_reactive_5 = tells_reactive_5_iter.next();
					runtime.history.Tuple3 $$tuple = null;					if (!stored || !(
						tells_reactive_5.$$$rule_12_history.contains($$tuple = new runtime.history.Tuple3(tells_reactive_5.getConstraintId(), this.ID, removes_5.getConstraintId()))
						|| removes_5.$$$rule_12_history.contains($$tuple)
						|| !$$$rule_12_history.insert($$tuple)
					)) {
						compiler.CHRIntermediateForm.constraints.ud.UserDefinedConstraint X = tells_reactive_5.$0;
						if (tracer != null)
							tracer.fires("$rule_12", 1, tells_reactive_5, this, removes_5);

						$$continuationStack.push(
							new RuleFiredContinuation("$rule_12", 1, true, tells_reactive_5, this, removes_5),
							new Exported_6_1(tells_reactive_5, removes_5, removes_5_iter, tells_reactive_5_iter)
						);
						return new RemovesConstraint(X, Y);
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("exported(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof RemovalHandler.ExportedConstraint)
			    && this.equals((ExportedConstraint)other);
		}

		public boolean equals(ExportedConstraint other) {
			if (this == other) return true;
			return this.$0.equals(other.$0);
		}

		private int hashCode;

		@Override
		public int hashCode() {
			if (!stored) {
				int hashCode = 37 * (23) + $0.hashCode();
				hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
				hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
				this.hashCode = hashCode;
				return hashCode;
			}
			return this.hashCode;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == Tells_reactiveConstraint.class)
			return true;
		if (constraintClass == TellsConstraint.class)
			return true;
		if (constraintClass == Tells_exportedConstraint.class)
			return true;
		if (constraintClass == RemovesConstraint.class)
			return true;
		if (constraintClass == ExportedConstraint.class)
			return true;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
